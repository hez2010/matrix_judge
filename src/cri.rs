// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct VersionRequest {
    // message fields
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionRequest {
    fn default() -> &'a VersionRequest {
        <VersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl VersionRequest {
    pub fn new() -> VersionRequest {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionRequest {
        VersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &VersionRequest| { &m.version },
                |m: &mut VersionRequest| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionRequest>(
                "VersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VersionRequest {
        static instance: ::protobuf::rt::LazyV2<VersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionRequest::new)
    }
}

impl ::protobuf::Clear for VersionRequest {
    fn clear(&mut self) {
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionResponse {
    // message fields
    pub version: ::std::string::String,
    pub runtime_name: ::std::string::String,
    pub runtime_version: ::std::string::String,
    pub runtime_api_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionResponse {
    fn default() -> &'a VersionResponse {
        <VersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponse {
    pub fn new() -> VersionResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string runtime_name = 2;


    pub fn get_runtime_name(&self) -> &str {
        &self.runtime_name
    }
    pub fn clear_runtime_name(&mut self) {
        self.runtime_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_name(&mut self, v: ::std::string::String) {
        self.runtime_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_name(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_name
    }

    // Take field
    pub fn take_runtime_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_name, ::std::string::String::new())
    }

    // string runtime_version = 3;


    pub fn get_runtime_version(&self) -> &str {
        &self.runtime_version
    }
    pub fn clear_runtime_version(&mut self) {
        self.runtime_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_version(&mut self, v: ::std::string::String) {
        self.runtime_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_version(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_version
    }

    // Take field
    pub fn take_runtime_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_version, ::std::string::String::new())
    }

    // string runtime_api_version = 4;


    pub fn get_runtime_api_version(&self) -> &str {
        &self.runtime_api_version
    }
    pub fn clear_runtime_api_version(&mut self) {
        self.runtime_api_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_api_version(&mut self, v: ::std::string::String) {
        self.runtime_api_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_api_version(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_api_version
    }

    // Take field
    pub fn take_runtime_api_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_api_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_api_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.runtime_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_name);
        }
        if !self.runtime_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.runtime_version);
        }
        if !self.runtime_api_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.runtime_api_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.runtime_name.is_empty() {
            os.write_string(2, &self.runtime_name)?;
        }
        if !self.runtime_version.is_empty() {
            os.write_string(3, &self.runtime_version)?;
        }
        if !self.runtime_api_version.is_empty() {
            os.write_string(4, &self.runtime_api_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionResponse {
        VersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &VersionResponse| { &m.version },
                |m: &mut VersionResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_name",
                |m: &VersionResponse| { &m.runtime_name },
                |m: &mut VersionResponse| { &mut m.runtime_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_version",
                |m: &VersionResponse| { &m.runtime_version },
                |m: &mut VersionResponse| { &mut m.runtime_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_api_version",
                |m: &VersionResponse| { &m.runtime_api_version },
                |m: &mut VersionResponse| { &mut m.runtime_api_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionResponse>(
                "VersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VersionResponse {
        static instance: ::protobuf::rt::LazyV2<VersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionResponse::new)
    }
}

impl ::protobuf::Clear for VersionResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.runtime_name.clear();
        self.runtime_version.clear();
        self.runtime_api_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DNSConfig {
    // message fields
    pub servers: ::protobuf::RepeatedField<::std::string::String>,
    pub searches: ::protobuf::RepeatedField<::std::string::String>,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DNSConfig {
    fn default() -> &'a DNSConfig {
        <DNSConfig as ::protobuf::Message>::default_instance()
    }
}

impl DNSConfig {
    pub fn new() -> DNSConfig {
        ::std::default::Default::default()
    }

    // repeated string servers = 1;


    pub fn get_servers(&self) -> &[::std::string::String] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }

    // repeated string searches = 2;


    pub fn get_searches(&self) -> &[::std::string::String] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // repeated string options = 3;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DNSConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.servers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.searches {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_string(1, &v)?;
        };
        for v in &self.searches {
            os.write_string(2, &v)?;
        };
        for v in &self.options {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DNSConfig {
        DNSConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "servers",
                |m: &DNSConfig| { &m.servers },
                |m: &mut DNSConfig| { &mut m.servers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searches",
                |m: &DNSConfig| { &m.searches },
                |m: &mut DNSConfig| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "options",
                |m: &DNSConfig| { &m.options },
                |m: &mut DNSConfig| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DNSConfig>(
                "DNSConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DNSConfig {
        static instance: ::protobuf::rt::LazyV2<DNSConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DNSConfig::new)
    }
}

impl ::protobuf::Clear for DNSConfig {
    fn clear(&mut self) {
        self.servers.clear();
        self.searches.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DNSConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNSConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortMapping {
    // message fields
    pub protocol: Protocol,
    pub container_port: i32,
    pub host_port: i32,
    pub host_ip: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortMapping {
    fn default() -> &'a PortMapping {
        <PortMapping as ::protobuf::Message>::default_instance()
    }
}

impl PortMapping {
    pub fn new() -> PortMapping {
        ::std::default::Default::default()
    }

    // .runtime.v1.Protocol protocol = 1;


    pub fn get_protocol(&self) -> Protocol {
        self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol = Protocol::TCP;
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: Protocol) {
        self.protocol = v;
    }

    // int32 container_port = 2;


    pub fn get_container_port(&self) -> i32 {
        self.container_port
    }
    pub fn clear_container_port(&mut self) {
        self.container_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_container_port(&mut self, v: i32) {
        self.container_port = v;
    }

    // int32 host_port = 3;


    pub fn get_host_port(&self) -> i32 {
        self.host_port
    }
    pub fn clear_host_port(&mut self) {
        self.host_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_port(&mut self, v: i32) {
        self.host_port = v;
    }

    // string host_ip = 4;


    pub fn get_host_ip(&self) -> &str {
        &self.host_ip
    }
    pub fn clear_host_ip(&mut self) {
        self.host_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_ip(&mut self, v: ::std::string::String) {
        self.host_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_ip(&mut self) -> &mut ::std::string::String {
        &mut self.host_ip
    }

    // Take field
    pub fn take_host_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_ip, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortMapping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.protocol, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.container_port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.host_port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.protocol != Protocol::TCP {
            my_size += ::protobuf::rt::enum_size(1, self.protocol);
        }
        if self.container_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.container_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.host_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.host_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.host_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.host_ip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.protocol != Protocol::TCP {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.protocol))?;
        }
        if self.container_port != 0 {
            os.write_int32(2, self.container_port)?;
        }
        if self.host_port != 0 {
            os.write_int32(3, self.host_port)?;
        }
        if !self.host_ip.is_empty() {
            os.write_string(4, &self.host_ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortMapping {
        PortMapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Protocol>>(
                "protocol",
                |m: &PortMapping| { &m.protocol },
                |m: &mut PortMapping| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "container_port",
                |m: &PortMapping| { &m.container_port },
                |m: &mut PortMapping| { &mut m.container_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "host_port",
                |m: &PortMapping| { &m.host_port },
                |m: &mut PortMapping| { &mut m.host_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_ip",
                |m: &PortMapping| { &m.host_ip },
                |m: &mut PortMapping| { &mut m.host_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortMapping>(
                "PortMapping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortMapping {
        static instance: ::protobuf::rt::LazyV2<PortMapping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortMapping::new)
    }
}

impl ::protobuf::Clear for PortMapping {
    fn clear(&mut self) {
        self.protocol = Protocol::TCP;
        self.container_port = 0;
        self.host_port = 0;
        self.host_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mount {
    // message fields
    pub container_path: ::std::string::String,
    pub host_path: ::std::string::String,
    pub readonly: bool,
    pub selinux_relabel: bool,
    pub propagation: MountPropagation,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mount {
    fn default() -> &'a Mount {
        <Mount as ::protobuf::Message>::default_instance()
    }
}

impl Mount {
    pub fn new() -> Mount {
        ::std::default::Default::default()
    }

    // string container_path = 1;


    pub fn get_container_path(&self) -> &str {
        &self.container_path
    }
    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        &mut self.container_path
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_path, ::std::string::String::new())
    }

    // string host_path = 2;


    pub fn get_host_path(&self) -> &str {
        &self.host_path
    }
    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: ::std::string::String) {
        self.host_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path(&mut self) -> &mut ::std::string::String {
        &mut self.host_path
    }

    // Take field
    pub fn take_host_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_path, ::std::string::String::new())
    }

    // bool readonly = 3;


    pub fn get_readonly(&self) -> bool {
        self.readonly
    }
    pub fn clear_readonly(&mut self) {
        self.readonly = false;
    }

    // Param is passed by value, moved
    pub fn set_readonly(&mut self, v: bool) {
        self.readonly = v;
    }

    // bool selinux_relabel = 4;


    pub fn get_selinux_relabel(&self) -> bool {
        self.selinux_relabel
    }
    pub fn clear_selinux_relabel(&mut self) {
        self.selinux_relabel = false;
    }

    // Param is passed by value, moved
    pub fn set_selinux_relabel(&mut self, v: bool) {
        self.selinux_relabel = v;
    }

    // .runtime.v1.MountPropagation propagation = 5;


    pub fn get_propagation(&self) -> MountPropagation {
        self.propagation
    }
    pub fn clear_propagation(&mut self) {
        self.propagation = MountPropagation::PROPAGATION_PRIVATE;
    }

    // Param is passed by value, moved
    pub fn set_propagation(&mut self, v: MountPropagation) {
        self.propagation = v;
    }
}

impl ::protobuf::Message for Mount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readonly = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selinux_relabel = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.propagation, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_path);
        }
        if !self.host_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host_path);
        }
        if self.readonly != false {
            my_size += 2;
        }
        if self.selinux_relabel != false {
            my_size += 2;
        }
        if self.propagation != MountPropagation::PROPAGATION_PRIVATE {
            my_size += ::protobuf::rt::enum_size(5, self.propagation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_path.is_empty() {
            os.write_string(1, &self.container_path)?;
        }
        if !self.host_path.is_empty() {
            os.write_string(2, &self.host_path)?;
        }
        if self.readonly != false {
            os.write_bool(3, self.readonly)?;
        }
        if self.selinux_relabel != false {
            os.write_bool(4, self.selinux_relabel)?;
        }
        if self.propagation != MountPropagation::PROPAGATION_PRIVATE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.propagation))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mount {
        Mount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_path",
                |m: &Mount| { &m.container_path },
                |m: &mut Mount| { &mut m.container_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_path",
                |m: &Mount| { &m.host_path },
                |m: &mut Mount| { &mut m.host_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readonly",
                |m: &Mount| { &m.readonly },
                |m: &mut Mount| { &mut m.readonly },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selinux_relabel",
                |m: &Mount| { &m.selinux_relabel },
                |m: &mut Mount| { &mut m.selinux_relabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MountPropagation>>(
                "propagation",
                |m: &Mount| { &m.propagation },
                |m: &mut Mount| { &mut m.propagation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mount>(
                "Mount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mount {
        static instance: ::protobuf::rt::LazyV2<Mount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mount::new)
    }
}

impl ::protobuf::Clear for Mount {
    fn clear(&mut self) {
        self.container_path.clear();
        self.host_path.clear();
        self.readonly = false;
        self.selinux_relabel = false;
        self.propagation = MountPropagation::PROPAGATION_PRIVATE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceOption {
    // message fields
    pub network: NamespaceMode,
    pub pid: NamespaceMode,
    pub ipc: NamespaceMode,
    pub target_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceOption {
    fn default() -> &'a NamespaceOption {
        <NamespaceOption as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceOption {
    pub fn new() -> NamespaceOption {
        ::std::default::Default::default()
    }

    // .runtime.v1.NamespaceMode network = 1;


    pub fn get_network(&self) -> NamespaceMode {
        self.network
    }
    pub fn clear_network(&mut self) {
        self.network = NamespaceMode::POD;
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: NamespaceMode) {
        self.network = v;
    }

    // .runtime.v1.NamespaceMode pid = 2;


    pub fn get_pid(&self) -> NamespaceMode {
        self.pid
    }
    pub fn clear_pid(&mut self) {
        self.pid = NamespaceMode::POD;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: NamespaceMode) {
        self.pid = v;
    }

    // .runtime.v1.NamespaceMode ipc = 3;


    pub fn get_ipc(&self) -> NamespaceMode {
        self.ipc
    }
    pub fn clear_ipc(&mut self) {
        self.ipc = NamespaceMode::POD;
    }

    // Param is passed by value, moved
    pub fn set_ipc(&mut self, v: NamespaceMode) {
        self.ipc = v;
    }

    // string target_id = 4;


    pub fn get_target_id(&self) -> &str {
        &self.target_id
    }
    pub fn clear_target_id(&mut self) {
        self.target_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: ::std::string::String) {
        self.target_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_id(&mut self) -> &mut ::std::string::String {
        &mut self.target_id
    }

    // Take field
    pub fn take_target_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NamespaceOption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.network, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.pid, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ipc, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.network != NamespaceMode::POD {
            my_size += ::protobuf::rt::enum_size(1, self.network);
        }
        if self.pid != NamespaceMode::POD {
            my_size += ::protobuf::rt::enum_size(2, self.pid);
        }
        if self.ipc != NamespaceMode::POD {
            my_size += ::protobuf::rt::enum_size(3, self.ipc);
        }
        if !self.target_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.target_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.network != NamespaceMode::POD {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.network))?;
        }
        if self.pid != NamespaceMode::POD {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.pid))?;
        }
        if self.ipc != NamespaceMode::POD {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.ipc))?;
        }
        if !self.target_id.is_empty() {
            os.write_string(4, &self.target_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceOption {
        NamespaceOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamespaceMode>>(
                "network",
                |m: &NamespaceOption| { &m.network },
                |m: &mut NamespaceOption| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamespaceMode>>(
                "pid",
                |m: &NamespaceOption| { &m.pid },
                |m: &mut NamespaceOption| { &mut m.pid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamespaceMode>>(
                "ipc",
                |m: &NamespaceOption| { &m.ipc },
                |m: &mut NamespaceOption| { &mut m.ipc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "target_id",
                |m: &NamespaceOption| { &m.target_id },
                |m: &mut NamespaceOption| { &mut m.target_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamespaceOption>(
                "NamespaceOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamespaceOption {
        static instance: ::protobuf::rt::LazyV2<NamespaceOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamespaceOption::new)
    }
}

impl ::protobuf::Clear for NamespaceOption {
    fn clear(&mut self) {
        self.network = NamespaceMode::POD;
        self.pid = NamespaceMode::POD;
        self.ipc = NamespaceMode::POD;
        self.target_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Int64Value {
    // message fields
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Int64Value {
    fn default() -> &'a Int64Value {
        <Int64Value as ::protobuf::Message>::default_instance()
    }
}

impl Int64Value {
    pub fn new() -> Int64Value {
        ::std::default::Default::default()
    }

    // int64 value = 1;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for Int64Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Int64Value {
        Int64Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &Int64Value| { &m.value },
                |m: &mut Int64Value| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Int64Value>(
                "Int64Value",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Int64Value {
        static instance: ::protobuf::rt::LazyV2<Int64Value> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Int64Value::new)
    }
}

impl ::protobuf::Clear for Int64Value {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Int64Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Int64Value {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxSandboxSecurityContext {
    // message fields
    pub namespace_options: ::protobuf::SingularPtrField<NamespaceOption>,
    pub selinux_options: ::protobuf::SingularPtrField<SELinuxOption>,
    pub run_as_user: ::protobuf::SingularPtrField<Int64Value>,
    pub run_as_group: ::protobuf::SingularPtrField<Int64Value>,
    pub readonly_rootfs: bool,
    pub supplemental_groups: ::std::vec::Vec<i64>,
    pub privileged: bool,
    pub seccomp: ::protobuf::SingularPtrField<SecurityProfile>,
    pub apparmor: ::protobuf::SingularPtrField<SecurityProfile>,
    pub seccomp_profile_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxSandboxSecurityContext {
    fn default() -> &'a LinuxSandboxSecurityContext {
        <LinuxSandboxSecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl LinuxSandboxSecurityContext {
    pub fn new() -> LinuxSandboxSecurityContext {
        ::std::default::Default::default()
    }

    // .runtime.v1.NamespaceOption namespace_options = 1;


    pub fn get_namespace_options(&self) -> &NamespaceOption {
        self.namespace_options.as_ref().unwrap_or_else(|| <NamespaceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namespace_options(&mut self) {
        self.namespace_options.clear();
    }

    pub fn has_namespace_options(&self) -> bool {
        self.namespace_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace_options(&mut self, v: NamespaceOption) {
        self.namespace_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace_options(&mut self) -> &mut NamespaceOption {
        if self.namespace_options.is_none() {
            self.namespace_options.set_default();
        }
        self.namespace_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace_options(&mut self) -> NamespaceOption {
        self.namespace_options.take().unwrap_or_else(|| NamespaceOption::new())
    }

    // .runtime.v1.SELinuxOption selinux_options = 2;


    pub fn get_selinux_options(&self) -> &SELinuxOption {
        self.selinux_options.as_ref().unwrap_or_else(|| <SELinuxOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selinux_options(&mut self) {
        self.selinux_options.clear();
    }

    pub fn has_selinux_options(&self) -> bool {
        self.selinux_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selinux_options(&mut self, v: SELinuxOption) {
        self.selinux_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selinux_options(&mut self) -> &mut SELinuxOption {
        if self.selinux_options.is_none() {
            self.selinux_options.set_default();
        }
        self.selinux_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_selinux_options(&mut self) -> SELinuxOption {
        self.selinux_options.take().unwrap_or_else(|| SELinuxOption::new())
    }

    // .runtime.v1.Int64Value run_as_user = 3;


    pub fn get_run_as_user(&self) -> &Int64Value {
        self.run_as_user.as_ref().unwrap_or_else(|| <Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_run_as_user(&mut self) {
        self.run_as_user.clear();
    }

    pub fn has_run_as_user(&self) -> bool {
        self.run_as_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_as_user(&mut self, v: Int64Value) {
        self.run_as_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_user(&mut self) -> &mut Int64Value {
        if self.run_as_user.is_none() {
            self.run_as_user.set_default();
        }
        self.run_as_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_run_as_user(&mut self) -> Int64Value {
        self.run_as_user.take().unwrap_or_else(|| Int64Value::new())
    }

    // .runtime.v1.Int64Value run_as_group = 8;


    pub fn get_run_as_group(&self) -> &Int64Value {
        self.run_as_group.as_ref().unwrap_or_else(|| <Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_run_as_group(&mut self) {
        self.run_as_group.clear();
    }

    pub fn has_run_as_group(&self) -> bool {
        self.run_as_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_as_group(&mut self, v: Int64Value) {
        self.run_as_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_group(&mut self) -> &mut Int64Value {
        if self.run_as_group.is_none() {
            self.run_as_group.set_default();
        }
        self.run_as_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_run_as_group(&mut self) -> Int64Value {
        self.run_as_group.take().unwrap_or_else(|| Int64Value::new())
    }

    // bool readonly_rootfs = 4;


    pub fn get_readonly_rootfs(&self) -> bool {
        self.readonly_rootfs
    }
    pub fn clear_readonly_rootfs(&mut self) {
        self.readonly_rootfs = false;
    }

    // Param is passed by value, moved
    pub fn set_readonly_rootfs(&mut self, v: bool) {
        self.readonly_rootfs = v;
    }

    // repeated int64 supplemental_groups = 5;


    pub fn get_supplemental_groups(&self) -> &[i64] {
        &self.supplemental_groups
    }
    pub fn clear_supplemental_groups(&mut self) {
        self.supplemental_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplemental_groups(&mut self, v: ::std::vec::Vec<i64>) {
        self.supplemental_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supplemental_groups(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplemental_groups
    }

    // Take field
    pub fn take_supplemental_groups(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.supplemental_groups, ::std::vec::Vec::new())
    }

    // bool privileged = 6;


    pub fn get_privileged(&self) -> bool {
        self.privileged
    }
    pub fn clear_privileged(&mut self) {
        self.privileged = false;
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = v;
    }

    // .runtime.v1.SecurityProfile seccomp = 9;


    pub fn get_seccomp(&self) -> &SecurityProfile {
        self.seccomp.as_ref().unwrap_or_else(|| <SecurityProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seccomp(&mut self) {
        self.seccomp.clear();
    }

    pub fn has_seccomp(&self) -> bool {
        self.seccomp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccomp(&mut self, v: SecurityProfile) {
        self.seccomp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccomp(&mut self) -> &mut SecurityProfile {
        if self.seccomp.is_none() {
            self.seccomp.set_default();
        }
        self.seccomp.as_mut().unwrap()
    }

    // Take field
    pub fn take_seccomp(&mut self) -> SecurityProfile {
        self.seccomp.take().unwrap_or_else(|| SecurityProfile::new())
    }

    // .runtime.v1.SecurityProfile apparmor = 10;


    pub fn get_apparmor(&self) -> &SecurityProfile {
        self.apparmor.as_ref().unwrap_or_else(|| <SecurityProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apparmor(&mut self) {
        self.apparmor.clear();
    }

    pub fn has_apparmor(&self) -> bool {
        self.apparmor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apparmor(&mut self, v: SecurityProfile) {
        self.apparmor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apparmor(&mut self) -> &mut SecurityProfile {
        if self.apparmor.is_none() {
            self.apparmor.set_default();
        }
        self.apparmor.as_mut().unwrap()
    }

    // Take field
    pub fn take_apparmor(&mut self) -> SecurityProfile {
        self.apparmor.take().unwrap_or_else(|| SecurityProfile::new())
    }

    // string seccomp_profile_path = 7;


    pub fn get_seccomp_profile_path(&self) -> &str {
        &self.seccomp_profile_path
    }
    pub fn clear_seccomp_profile_path(&mut self) {
        self.seccomp_profile_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_seccomp_profile_path(&mut self, v: ::std::string::String) {
        self.seccomp_profile_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccomp_profile_path(&mut self) -> &mut ::std::string::String {
        &mut self.seccomp_profile_path
    }

    // Take field
    pub fn take_seccomp_profile_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seccomp_profile_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxSandboxSecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.namespace_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selinux_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.run_as_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.run_as_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seccomp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apparmor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namespace_options)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selinux_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.run_as_user)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.run_as_group)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readonly_rootfs = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.supplemental_groups)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seccomp)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apparmor)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seccomp_profile_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selinux_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.run_as_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.run_as_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.readonly_rootfs != false {
            my_size += 2;
        }
        for value in &self.supplemental_groups {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.privileged != false {
            my_size += 2;
        }
        if let Some(ref v) = self.seccomp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apparmor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.seccomp_profile_path.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.seccomp_profile_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace_options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selinux_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.run_as_user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.run_as_group.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.readonly_rootfs != false {
            os.write_bool(4, self.readonly_rootfs)?;
        }
        for v in &self.supplemental_groups {
            os.write_int64(5, *v)?;
        };
        if self.privileged != false {
            os.write_bool(6, self.privileged)?;
        }
        if let Some(ref v) = self.seccomp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apparmor.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.seccomp_profile_path.is_empty() {
            os.write_string(7, &self.seccomp_profile_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxSandboxSecurityContext {
        LinuxSandboxSecurityContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceOption>>(
                "namespace_options",
                |m: &LinuxSandboxSecurityContext| { &m.namespace_options },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.namespace_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOption>>(
                "selinux_options",
                |m: &LinuxSandboxSecurityContext| { &m.selinux_options },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.selinux_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Int64Value>>(
                "run_as_user",
                |m: &LinuxSandboxSecurityContext| { &m.run_as_user },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.run_as_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Int64Value>>(
                "run_as_group",
                |m: &LinuxSandboxSecurityContext| { &m.run_as_group },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.run_as_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readonly_rootfs",
                |m: &LinuxSandboxSecurityContext| { &m.readonly_rootfs },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.readonly_rootfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "supplemental_groups",
                |m: &LinuxSandboxSecurityContext| { &m.supplemental_groups },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.supplemental_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "privileged",
                |m: &LinuxSandboxSecurityContext| { &m.privileged },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.privileged },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityProfile>>(
                "seccomp",
                |m: &LinuxSandboxSecurityContext| { &m.seccomp },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.seccomp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityProfile>>(
                "apparmor",
                |m: &LinuxSandboxSecurityContext| { &m.apparmor },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.apparmor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seccomp_profile_path",
                |m: &LinuxSandboxSecurityContext| { &m.seccomp_profile_path },
                |m: &mut LinuxSandboxSecurityContext| { &mut m.seccomp_profile_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxSandboxSecurityContext>(
                "LinuxSandboxSecurityContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxSandboxSecurityContext {
        static instance: ::protobuf::rt::LazyV2<LinuxSandboxSecurityContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxSandboxSecurityContext::new)
    }
}

impl ::protobuf::Clear for LinuxSandboxSecurityContext {
    fn clear(&mut self) {
        self.namespace_options.clear();
        self.selinux_options.clear();
        self.run_as_user.clear();
        self.run_as_group.clear();
        self.readonly_rootfs = false;
        self.supplemental_groups.clear();
        self.privileged = false;
        self.seccomp.clear();
        self.apparmor.clear();
        self.seccomp_profile_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxSandboxSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxSandboxSecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurityProfile {
    // message fields
    pub profile_type: SecurityProfile_ProfileType,
    pub localhost_ref: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecurityProfile {
    fn default() -> &'a SecurityProfile {
        <SecurityProfile as ::protobuf::Message>::default_instance()
    }
}

impl SecurityProfile {
    pub fn new() -> SecurityProfile {
        ::std::default::Default::default()
    }

    // .runtime.v1.SecurityProfile.ProfileType profile_type = 1;


    pub fn get_profile_type(&self) -> SecurityProfile_ProfileType {
        self.profile_type
    }
    pub fn clear_profile_type(&mut self) {
        self.profile_type = SecurityProfile_ProfileType::RuntimeDefault;
    }

    // Param is passed by value, moved
    pub fn set_profile_type(&mut self, v: SecurityProfile_ProfileType) {
        self.profile_type = v;
    }

    // string localhost_ref = 2;


    pub fn get_localhost_ref(&self) -> &str {
        &self.localhost_ref
    }
    pub fn clear_localhost_ref(&mut self) {
        self.localhost_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_localhost_ref(&mut self, v: ::std::string::String) {
        self.localhost_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localhost_ref(&mut self) -> &mut ::std::string::String {
        &mut self.localhost_ref
    }

    // Take field
    pub fn take_localhost_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.localhost_ref, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecurityProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.profile_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.localhost_ref)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.profile_type != SecurityProfile_ProfileType::RuntimeDefault {
            my_size += ::protobuf::rt::enum_size(1, self.profile_type);
        }
        if !self.localhost_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.localhost_ref);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.profile_type != SecurityProfile_ProfileType::RuntimeDefault {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.profile_type))?;
        }
        if !self.localhost_ref.is_empty() {
            os.write_string(2, &self.localhost_ref)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecurityProfile {
        SecurityProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SecurityProfile_ProfileType>>(
                "profile_type",
                |m: &SecurityProfile| { &m.profile_type },
                |m: &mut SecurityProfile| { &mut m.profile_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localhost_ref",
                |m: &SecurityProfile| { &m.localhost_ref },
                |m: &mut SecurityProfile| { &mut m.localhost_ref },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecurityProfile>(
                "SecurityProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecurityProfile {
        static instance: ::protobuf::rt::LazyV2<SecurityProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecurityProfile::new)
    }
}

impl ::protobuf::Clear for SecurityProfile {
    fn clear(&mut self) {
        self.profile_type = SecurityProfile_ProfileType::RuntimeDefault;
        self.localhost_ref.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurityProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SecurityProfile_ProfileType {
    RuntimeDefault = 0,
    Unconfined = 1,
    Localhost = 2,
}

impl ::protobuf::ProtobufEnum for SecurityProfile_ProfileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SecurityProfile_ProfileType> {
        match value {
            0 => ::std::option::Option::Some(SecurityProfile_ProfileType::RuntimeDefault),
            1 => ::std::option::Option::Some(SecurityProfile_ProfileType::Unconfined),
            2 => ::std::option::Option::Some(SecurityProfile_ProfileType::Localhost),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SecurityProfile_ProfileType] = &[
            SecurityProfile_ProfileType::RuntimeDefault,
            SecurityProfile_ProfileType::Unconfined,
            SecurityProfile_ProfileType::Localhost,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SecurityProfile_ProfileType>("SecurityProfile.ProfileType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SecurityProfile_ProfileType {
}

impl ::std::default::Default for SecurityProfile_ProfileType {
    fn default() -> Self {
        SecurityProfile_ProfileType::RuntimeDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityProfile_ProfileType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxPodSandboxConfig {
    // message fields
    pub cgroup_parent: ::std::string::String,
    pub security_context: ::protobuf::SingularPtrField<LinuxSandboxSecurityContext>,
    pub sysctls: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxPodSandboxConfig {
    fn default() -> &'a LinuxPodSandboxConfig {
        <LinuxPodSandboxConfig as ::protobuf::Message>::default_instance()
    }
}

impl LinuxPodSandboxConfig {
    pub fn new() -> LinuxPodSandboxConfig {
        ::std::default::Default::default()
    }

    // string cgroup_parent = 1;


    pub fn get_cgroup_parent(&self) -> &str {
        &self.cgroup_parent
    }
    pub fn clear_cgroup_parent(&mut self) {
        self.cgroup_parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_cgroup_parent(&mut self, v: ::std::string::String) {
        self.cgroup_parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_parent(&mut self) -> &mut ::std::string::String {
        &mut self.cgroup_parent
    }

    // Take field
    pub fn take_cgroup_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cgroup_parent, ::std::string::String::new())
    }

    // .runtime.v1.LinuxSandboxSecurityContext security_context = 2;


    pub fn get_security_context(&self) -> &LinuxSandboxSecurityContext {
        self.security_context.as_ref().unwrap_or_else(|| <LinuxSandboxSecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_security_context(&mut self) {
        self.security_context.clear();
    }

    pub fn has_security_context(&self) -> bool {
        self.security_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_context(&mut self, v: LinuxSandboxSecurityContext) {
        self.security_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_context(&mut self) -> &mut LinuxSandboxSecurityContext {
        if self.security_context.is_none() {
            self.security_context.set_default();
        }
        self.security_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_context(&mut self) -> LinuxSandboxSecurityContext {
        self.security_context.take().unwrap_or_else(|| LinuxSandboxSecurityContext::new())
    }

    // repeated .runtime.v1.LinuxPodSandboxConfig.SysctlsEntry sysctls = 3;


    pub fn get_sysctls(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.sysctls
    }
    pub fn clear_sysctls(&mut self) {
        self.sysctls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sysctls(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.sysctls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sysctls(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.sysctls
    }

    // Take field
    pub fn take_sysctls(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.sysctls, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for LinuxPodSandboxConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.security_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cgroup_parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_context)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.sysctls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cgroup_parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cgroup_parent);
        }
        if let Some(ref v) = self.security_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.sysctls);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cgroup_parent.is_empty() {
            os.write_string(1, &self.cgroup_parent)?;
        }
        if let Some(ref v) = self.security_context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.sysctls, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxPodSandboxConfig {
        LinuxPodSandboxConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cgroup_parent",
                |m: &LinuxPodSandboxConfig| { &m.cgroup_parent },
                |m: &mut LinuxPodSandboxConfig| { &mut m.cgroup_parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxSandboxSecurityContext>>(
                "security_context",
                |m: &LinuxPodSandboxConfig| { &m.security_context },
                |m: &mut LinuxPodSandboxConfig| { &mut m.security_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "sysctls",
                |m: &LinuxPodSandboxConfig| { &m.sysctls },
                |m: &mut LinuxPodSandboxConfig| { &mut m.sysctls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxPodSandboxConfig>(
                "LinuxPodSandboxConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxPodSandboxConfig {
        static instance: ::protobuf::rt::LazyV2<LinuxPodSandboxConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxPodSandboxConfig::new)
    }
}

impl ::protobuf::Clear for LinuxPodSandboxConfig {
    fn clear(&mut self) {
        self.cgroup_parent.clear();
        self.security_context.clear();
        self.sysctls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxPodSandboxConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxPodSandboxConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxMetadata {
    // message fields
    pub name: ::std::string::String,
    pub uid: ::std::string::String,
    pub namespace: ::std::string::String,
    pub attempt: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxMetadata {
    fn default() -> &'a PodSandboxMetadata {
        <PodSandboxMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxMetadata {
    pub fn new() -> PodSandboxMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string uid = 2;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string namespace = 3;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // uint32 attempt = 4;


    pub fn get_attempt(&self) -> u32 {
        self.attempt
    }
    pub fn clear_attempt(&mut self) {
        self.attempt = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt(&mut self, v: u32) {
        self.attempt = v;
    }
}

impl ::protobuf::Message for PodSandboxMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uid);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        if self.attempt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.attempt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.uid.is_empty() {
            os.write_string(2, &self.uid)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        if self.attempt != 0 {
            os.write_uint32(4, self.attempt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxMetadata {
        PodSandboxMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PodSandboxMetadata| { &m.name },
                |m: &mut PodSandboxMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &PodSandboxMetadata| { &m.uid },
                |m: &mut PodSandboxMetadata| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &PodSandboxMetadata| { &m.namespace },
                |m: &mut PodSandboxMetadata| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attempt",
                |m: &PodSandboxMetadata| { &m.attempt },
                |m: &mut PodSandboxMetadata| { &mut m.attempt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxMetadata>(
                "PodSandboxMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxMetadata {
        static instance: ::protobuf::rt::LazyV2<PodSandboxMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxMetadata::new)
    }
}

impl ::protobuf::Clear for PodSandboxMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.uid.clear();
        self.namespace.clear();
        self.attempt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxConfig {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<PodSandboxMetadata>,
    pub hostname: ::std::string::String,
    pub log_directory: ::std::string::String,
    pub dns_config: ::protobuf::SingularPtrField<DNSConfig>,
    pub port_mappings: ::protobuf::RepeatedField<PortMapping>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub linux: ::protobuf::SingularPtrField<LinuxPodSandboxConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxConfig {
    fn default() -> &'a PodSandboxConfig {
        <PodSandboxConfig as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxConfig {
    pub fn new() -> PodSandboxConfig {
        ::std::default::Default::default()
    }

    // .runtime.v1.PodSandboxMetadata metadata = 1;


    pub fn get_metadata(&self) -> &PodSandboxMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <PodSandboxMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: PodSandboxMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut PodSandboxMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> PodSandboxMetadata {
        self.metadata.take().unwrap_or_else(|| PodSandboxMetadata::new())
    }

    // string hostname = 2;


    pub fn get_hostname(&self) -> &str {
        &self.hostname
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        &mut self.hostname
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hostname, ::std::string::String::new())
    }

    // string log_directory = 3;


    pub fn get_log_directory(&self) -> &str {
        &self.log_directory
    }
    pub fn clear_log_directory(&mut self) {
        self.log_directory.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_directory(&mut self, v: ::std::string::String) {
        self.log_directory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_directory(&mut self) -> &mut ::std::string::String {
        &mut self.log_directory
    }

    // Take field
    pub fn take_log_directory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_directory, ::std::string::String::new())
    }

    // .runtime.v1.DNSConfig dns_config = 4;


    pub fn get_dns_config(&self) -> &DNSConfig {
        self.dns_config.as_ref().unwrap_or_else(|| <DNSConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dns_config(&mut self) {
        self.dns_config.clear();
    }

    pub fn has_dns_config(&self) -> bool {
        self.dns_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dns_config(&mut self, v: DNSConfig) {
        self.dns_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dns_config(&mut self) -> &mut DNSConfig {
        if self.dns_config.is_none() {
            self.dns_config.set_default();
        }
        self.dns_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_dns_config(&mut self) -> DNSConfig {
        self.dns_config.take().unwrap_or_else(|| DNSConfig::new())
    }

    // repeated .runtime.v1.PortMapping port_mappings = 5;


    pub fn get_port_mappings(&self) -> &[PortMapping] {
        &self.port_mappings
    }
    pub fn clear_port_mappings(&mut self) {
        self.port_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_mappings(&mut self, v: ::protobuf::RepeatedField<PortMapping>) {
        self.port_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_mappings(&mut self) -> &mut ::protobuf::RepeatedField<PortMapping> {
        &mut self.port_mappings
    }

    // Take field
    pub fn take_port_mappings(&mut self) -> ::protobuf::RepeatedField<PortMapping> {
        ::std::mem::replace(&mut self.port_mappings, ::protobuf::RepeatedField::new())
    }

    // repeated .runtime.v1.PodSandboxConfig.LabelsEntry labels = 6;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.PodSandboxConfig.AnnotationsEntry annotations = 7;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // .runtime.v1.LinuxPodSandboxConfig linux = 8;


    pub fn get_linux(&self) -> &LinuxPodSandboxConfig {
        self.linux.as_ref().unwrap_or_else(|| <LinuxPodSandboxConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux(&mut self) {
        self.linux.clear();
    }

    pub fn has_linux(&self) -> bool {
        self.linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux(&mut self, v: LinuxPodSandboxConfig) {
        self.linux = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux(&mut self) -> &mut LinuxPodSandboxConfig {
        if self.linux.is_none() {
            self.linux.set_default();
        }
        self.linux.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux(&mut self) -> LinuxPodSandboxConfig {
        self.linux.take().unwrap_or_else(|| LinuxPodSandboxConfig::new())
    }
}

impl ::protobuf::Message for PodSandboxConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dns_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.port_mappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linux {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hostname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_directory)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dns_config)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_mappings)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hostname);
        }
        if !self.log_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.log_directory);
        }
        if let Some(ref v) = self.dns_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.port_mappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.annotations);
        if let Some(ref v) = self.linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hostname.is_empty() {
            os.write_string(2, &self.hostname)?;
        }
        if !self.log_directory.is_empty() {
            os.write_string(3, &self.log_directory)?;
        }
        if let Some(ref v) = self.dns_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.port_mappings {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.annotations, os)?;
        if let Some(ref v) = self.linux.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxConfig {
        PodSandboxConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxMetadata>>(
                "metadata",
                |m: &PodSandboxConfig| { &m.metadata },
                |m: &mut PodSandboxConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &PodSandboxConfig| { &m.hostname },
                |m: &mut PodSandboxConfig| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "log_directory",
                |m: &PodSandboxConfig| { &m.log_directory },
                |m: &mut PodSandboxConfig| { &mut m.log_directory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DNSConfig>>(
                "dns_config",
                |m: &PodSandboxConfig| { &m.dns_config },
                |m: &mut PodSandboxConfig| { &mut m.dns_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortMapping>>(
                "port_mappings",
                |m: &PodSandboxConfig| { &m.port_mappings },
                |m: &mut PodSandboxConfig| { &mut m.port_mappings },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &PodSandboxConfig| { &m.labels },
                |m: &mut PodSandboxConfig| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &PodSandboxConfig| { &m.annotations },
                |m: &mut PodSandboxConfig| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxPodSandboxConfig>>(
                "linux",
                |m: &PodSandboxConfig| { &m.linux },
                |m: &mut PodSandboxConfig| { &mut m.linux },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxConfig>(
                "PodSandboxConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxConfig {
        static instance: ::protobuf::rt::LazyV2<PodSandboxConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxConfig::new)
    }
}

impl ::protobuf::Clear for PodSandboxConfig {
    fn clear(&mut self) {
        self.metadata.clear();
        self.hostname.clear();
        self.log_directory.clear();
        self.dns_config.clear();
        self.port_mappings.clear();
        self.labels.clear();
        self.annotations.clear();
        self.linux.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunPodSandboxRequest {
    // message fields
    pub config: ::protobuf::SingularPtrField<PodSandboxConfig>,
    pub runtime_handler: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunPodSandboxRequest {
    fn default() -> &'a RunPodSandboxRequest {
        <RunPodSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl RunPodSandboxRequest {
    pub fn new() -> RunPodSandboxRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.PodSandboxConfig config = 1;


    pub fn get_config(&self) -> &PodSandboxConfig {
        self.config.as_ref().unwrap_or_else(|| <PodSandboxConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: PodSandboxConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut PodSandboxConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> PodSandboxConfig {
        self.config.take().unwrap_or_else(|| PodSandboxConfig::new())
    }

    // string runtime_handler = 2;


    pub fn get_runtime_handler(&self) -> &str {
        &self.runtime_handler
    }
    pub fn clear_runtime_handler(&mut self) {
        self.runtime_handler.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_handler(&mut self, v: ::std::string::String) {
        self.runtime_handler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_handler(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_handler
    }

    // Take field
    pub fn take_runtime_handler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_handler, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RunPodSandboxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_handler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_handler.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_handler);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_handler.is_empty() {
            os.write_string(2, &self.runtime_handler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunPodSandboxRequest {
        RunPodSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxConfig>>(
                "config",
                |m: &RunPodSandboxRequest| { &m.config },
                |m: &mut RunPodSandboxRequest| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_handler",
                |m: &RunPodSandboxRequest| { &m.runtime_handler },
                |m: &mut RunPodSandboxRequest| { &mut m.runtime_handler },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RunPodSandboxRequest>(
                "RunPodSandboxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RunPodSandboxRequest {
        static instance: ::protobuf::rt::LazyV2<RunPodSandboxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RunPodSandboxRequest::new)
    }
}

impl ::protobuf::Clear for RunPodSandboxRequest {
    fn clear(&mut self) {
        self.config.clear();
        self.runtime_handler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunPodSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunPodSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunPodSandboxResponse {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunPodSandboxResponse {
    fn default() -> &'a RunPodSandboxResponse {
        <RunPodSandboxResponse as ::protobuf::Message>::default_instance()
    }
}

impl RunPodSandboxResponse {
    pub fn new() -> RunPodSandboxResponse {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RunPodSandboxResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunPodSandboxResponse {
        RunPodSandboxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &RunPodSandboxResponse| { &m.pod_sandbox_id },
                |m: &mut RunPodSandboxResponse| { &mut m.pod_sandbox_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RunPodSandboxResponse>(
                "RunPodSandboxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RunPodSandboxResponse {
        static instance: ::protobuf::rt::LazyV2<RunPodSandboxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RunPodSandboxResponse::new)
    }
}

impl ::protobuf::Clear for RunPodSandboxResponse {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunPodSandboxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunPodSandboxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopPodSandboxRequest {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopPodSandboxRequest {
    fn default() -> &'a StopPodSandboxRequest {
        <StopPodSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopPodSandboxRequest {
    pub fn new() -> StopPodSandboxRequest {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StopPodSandboxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopPodSandboxRequest {
        StopPodSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &StopPodSandboxRequest| { &m.pod_sandbox_id },
                |m: &mut StopPodSandboxRequest| { &mut m.pod_sandbox_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopPodSandboxRequest>(
                "StopPodSandboxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopPodSandboxRequest {
        static instance: ::protobuf::rt::LazyV2<StopPodSandboxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopPodSandboxRequest::new)
    }
}

impl ::protobuf::Clear for StopPodSandboxRequest {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopPodSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopPodSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopPodSandboxResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopPodSandboxResponse {
    fn default() -> &'a StopPodSandboxResponse {
        <StopPodSandboxResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopPodSandboxResponse {
    pub fn new() -> StopPodSandboxResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopPodSandboxResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopPodSandboxResponse {
        StopPodSandboxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopPodSandboxResponse>(
                "StopPodSandboxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopPodSandboxResponse {
        static instance: ::protobuf::rt::LazyV2<StopPodSandboxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopPodSandboxResponse::new)
    }
}

impl ::protobuf::Clear for StopPodSandboxResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopPodSandboxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopPodSandboxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemovePodSandboxRequest {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemovePodSandboxRequest {
    fn default() -> &'a RemovePodSandboxRequest {
        <RemovePodSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemovePodSandboxRequest {
    pub fn new() -> RemovePodSandboxRequest {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemovePodSandboxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemovePodSandboxRequest {
        RemovePodSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &RemovePodSandboxRequest| { &m.pod_sandbox_id },
                |m: &mut RemovePodSandboxRequest| { &mut m.pod_sandbox_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemovePodSandboxRequest>(
                "RemovePodSandboxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemovePodSandboxRequest {
        static instance: ::protobuf::rt::LazyV2<RemovePodSandboxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemovePodSandboxRequest::new)
    }
}

impl ::protobuf::Clear for RemovePodSandboxRequest {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemovePodSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePodSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemovePodSandboxResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemovePodSandboxResponse {
    fn default() -> &'a RemovePodSandboxResponse {
        <RemovePodSandboxResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemovePodSandboxResponse {
    pub fn new() -> RemovePodSandboxResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemovePodSandboxResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemovePodSandboxResponse {
        RemovePodSandboxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemovePodSandboxResponse>(
                "RemovePodSandboxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemovePodSandboxResponse {
        static instance: ::protobuf::rt::LazyV2<RemovePodSandboxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemovePodSandboxResponse::new)
    }
}

impl ::protobuf::Clear for RemovePodSandboxResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemovePodSandboxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePodSandboxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxStatusRequest {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    pub verbose: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxStatusRequest {
    fn default() -> &'a PodSandboxStatusRequest {
        <PodSandboxStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxStatusRequest {
    pub fn new() -> PodSandboxStatusRequest {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // bool verbose = 2;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }
}

impl ::protobuf::Message for PodSandboxStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        if self.verbose != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        if self.verbose != false {
            os.write_bool(2, self.verbose)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxStatusRequest {
        PodSandboxStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &PodSandboxStatusRequest| { &m.pod_sandbox_id },
                |m: &mut PodSandboxStatusRequest| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verbose",
                |m: &PodSandboxStatusRequest| { &m.verbose },
                |m: &mut PodSandboxStatusRequest| { &mut m.verbose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxStatusRequest>(
                "PodSandboxStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxStatusRequest {
        static instance: ::protobuf::rt::LazyV2<PodSandboxStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxStatusRequest::new)
    }
}

impl ::protobuf::Clear for PodSandboxStatusRequest {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.verbose = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodIP {
    // message fields
    pub ip: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodIP {
    fn default() -> &'a PodIP {
        <PodIP as ::protobuf::Message>::default_instance()
    }
}

impl PodIP {
    pub fn new() -> PodIP {
        ::std::default::Default::default()
    }

    // string ip = 1;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodIP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ip.is_empty() {
            os.write_string(1, &self.ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodIP {
        PodIP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &PodIP| { &m.ip },
                |m: &mut PodIP| { &mut m.ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodIP>(
                "PodIP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodIP {
        static instance: ::protobuf::rt::LazyV2<PodIP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodIP::new)
    }
}

impl ::protobuf::Clear for PodIP {
    fn clear(&mut self) {
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodIP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxNetworkStatus {
    // message fields
    pub ip: ::std::string::String,
    pub additional_ips: ::protobuf::RepeatedField<PodIP>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxNetworkStatus {
    fn default() -> &'a PodSandboxNetworkStatus {
        <PodSandboxNetworkStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxNetworkStatus {
    pub fn new() -> PodSandboxNetworkStatus {
        ::std::default::Default::default()
    }

    // string ip = 1;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // repeated .runtime.v1.PodIP additional_ips = 2;


    pub fn get_additional_ips(&self) -> &[PodIP] {
        &self.additional_ips
    }
    pub fn clear_additional_ips(&mut self) {
        self.additional_ips.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_ips(&mut self, v: ::protobuf::RepeatedField<PodIP>) {
        self.additional_ips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_ips(&mut self) -> &mut ::protobuf::RepeatedField<PodIP> {
        &mut self.additional_ips
    }

    // Take field
    pub fn take_additional_ips(&mut self) -> ::protobuf::RepeatedField<PodIP> {
        ::std::mem::replace(&mut self.additional_ips, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodSandboxNetworkStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.additional_ips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_ips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ip);
        }
        for value in &self.additional_ips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ip.is_empty() {
            os.write_string(1, &self.ip)?;
        }
        for v in &self.additional_ips {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxNetworkStatus {
        PodSandboxNetworkStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &PodSandboxNetworkStatus| { &m.ip },
                |m: &mut PodSandboxNetworkStatus| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodIP>>(
                "additional_ips",
                |m: &PodSandboxNetworkStatus| { &m.additional_ips },
                |m: &mut PodSandboxNetworkStatus| { &mut m.additional_ips },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxNetworkStatus>(
                "PodSandboxNetworkStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxNetworkStatus {
        static instance: ::protobuf::rt::LazyV2<PodSandboxNetworkStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxNetworkStatus::new)
    }
}

impl ::protobuf::Clear for PodSandboxNetworkStatus {
    fn clear(&mut self) {
        self.ip.clear();
        self.additional_ips.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxNetworkStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxNetworkStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Namespace {
    // message fields
    pub options: ::protobuf::SingularPtrField<NamespaceOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Namespace {
    fn default() -> &'a Namespace {
        <Namespace as ::protobuf::Message>::default_instance()
    }
}

impl Namespace {
    pub fn new() -> Namespace {
        ::std::default::Default::default()
    }

    // .runtime.v1.NamespaceOption options = 2;


    pub fn get_options(&self) -> &NamespaceOption {
        self.options.as_ref().unwrap_or_else(|| <NamespaceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: NamespaceOption) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut NamespaceOption {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> NamespaceOption {
        self.options.take().unwrap_or_else(|| NamespaceOption::new())
    }
}

impl ::protobuf::Message for Namespace {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Namespace {
        Namespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceOption>>(
                "options",
                |m: &Namespace| { &m.options },
                |m: &mut Namespace| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Namespace>(
                "Namespace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Namespace {
        static instance: ::protobuf::rt::LazyV2<Namespace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Namespace::new)
    }
}

impl ::protobuf::Clear for Namespace {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Namespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxPodSandboxStatus {
    // message fields
    pub namespaces: ::protobuf::SingularPtrField<Namespace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxPodSandboxStatus {
    fn default() -> &'a LinuxPodSandboxStatus {
        <LinuxPodSandboxStatus as ::protobuf::Message>::default_instance()
    }
}

impl LinuxPodSandboxStatus {
    pub fn new() -> LinuxPodSandboxStatus {
        ::std::default::Default::default()
    }

    // .runtime.v1.Namespace namespaces = 1;


    pub fn get_namespaces(&self) -> &Namespace {
        self.namespaces.as_ref().unwrap_or_else(|| <Namespace as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namespaces(&mut self) {
        self.namespaces.clear();
    }

    pub fn has_namespaces(&self) -> bool {
        self.namespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaces(&mut self, v: Namespace) {
        self.namespaces = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaces(&mut self) -> &mut Namespace {
        if self.namespaces.is_none() {
            self.namespaces.set_default();
        }
        self.namespaces.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespaces(&mut self) -> Namespace {
        self.namespaces.take().unwrap_or_else(|| Namespace::new())
    }
}

impl ::protobuf::Message for LinuxPodSandboxStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.namespaces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namespaces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespaces.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespaces.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxPodSandboxStatus {
        LinuxPodSandboxStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Namespace>>(
                "namespaces",
                |m: &LinuxPodSandboxStatus| { &m.namespaces },
                |m: &mut LinuxPodSandboxStatus| { &mut m.namespaces },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxPodSandboxStatus>(
                "LinuxPodSandboxStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxPodSandboxStatus {
        static instance: ::protobuf::rt::LazyV2<LinuxPodSandboxStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxPodSandboxStatus::new)
    }
}

impl ::protobuf::Clear for LinuxPodSandboxStatus {
    fn clear(&mut self) {
        self.namespaces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxPodSandboxStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxPodSandboxStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxStatus {
    // message fields
    pub id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<PodSandboxMetadata>,
    pub state: PodSandboxState,
    pub created_at: i64,
    pub network: ::protobuf::SingularPtrField<PodSandboxNetworkStatus>,
    pub linux: ::protobuf::SingularPtrField<LinuxPodSandboxStatus>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub runtime_handler: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxStatus {
    fn default() -> &'a PodSandboxStatus {
        <PodSandboxStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxStatus {
    pub fn new() -> PodSandboxStatus {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.PodSandboxMetadata metadata = 2;


    pub fn get_metadata(&self) -> &PodSandboxMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <PodSandboxMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: PodSandboxMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut PodSandboxMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> PodSandboxMetadata {
        self.metadata.take().unwrap_or_else(|| PodSandboxMetadata::new())
    }

    // .runtime.v1.PodSandboxState state = 3;


    pub fn get_state(&self) -> PodSandboxState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PodSandboxState::SANDBOX_READY;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PodSandboxState) {
        self.state = v;
    }

    // int64 created_at = 4;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // .runtime.v1.PodSandboxNetworkStatus network = 5;


    pub fn get_network(&self) -> &PodSandboxNetworkStatus {
        self.network.as_ref().unwrap_or_else(|| <PodSandboxNetworkStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: PodSandboxNetworkStatus) {
        self.network = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut PodSandboxNetworkStatus {
        if self.network.is_none() {
            self.network.set_default();
        }
        self.network.as_mut().unwrap()
    }

    // Take field
    pub fn take_network(&mut self) -> PodSandboxNetworkStatus {
        self.network.take().unwrap_or_else(|| PodSandboxNetworkStatus::new())
    }

    // .runtime.v1.LinuxPodSandboxStatus linux = 6;


    pub fn get_linux(&self) -> &LinuxPodSandboxStatus {
        self.linux.as_ref().unwrap_or_else(|| <LinuxPodSandboxStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux(&mut self) {
        self.linux.clear();
    }

    pub fn has_linux(&self) -> bool {
        self.linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux(&mut self, v: LinuxPodSandboxStatus) {
        self.linux = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux(&mut self) -> &mut LinuxPodSandboxStatus {
        if self.linux.is_none() {
            self.linux.set_default();
        }
        self.linux.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux(&mut self) -> LinuxPodSandboxStatus {
        self.linux.take().unwrap_or_else(|| LinuxPodSandboxStatus::new())
    }

    // repeated .runtime.v1.PodSandboxStatus.LabelsEntry labels = 7;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.PodSandboxStatus.AnnotationsEntry annotations = 8;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // string runtime_handler = 9;


    pub fn get_runtime_handler(&self) -> &str {
        &self.runtime_handler
    }
    pub fn clear_runtime_handler(&mut self) {
        self.runtime_handler.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_handler(&mut self, v: ::std::string::String) {
        self.runtime_handler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_handler(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_handler
    }

    // Take field
    pub fn take_runtime_handler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_handler, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodSandboxStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linux {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_at = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_handler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != PodSandboxState::SANDBOX_READY {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.annotations);
        if !self.runtime_handler.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.runtime_handler);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != PodSandboxState::SANDBOX_READY {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.created_at != 0 {
            os.write_int64(4, self.created_at)?;
        }
        if let Some(ref v) = self.network.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.linux.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.annotations, os)?;
        if !self.runtime_handler.is_empty() {
            os.write_string(9, &self.runtime_handler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxStatus {
        PodSandboxStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PodSandboxStatus| { &m.id },
                |m: &mut PodSandboxStatus| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxMetadata>>(
                "metadata",
                |m: &PodSandboxStatus| { &m.metadata },
                |m: &mut PodSandboxStatus| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PodSandboxState>>(
                "state",
                |m: &PodSandboxStatus| { &m.state },
                |m: &mut PodSandboxStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "created_at",
                |m: &PodSandboxStatus| { &m.created_at },
                |m: &mut PodSandboxStatus| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxNetworkStatus>>(
                "network",
                |m: &PodSandboxStatus| { &m.network },
                |m: &mut PodSandboxStatus| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxPodSandboxStatus>>(
                "linux",
                |m: &PodSandboxStatus| { &m.linux },
                |m: &mut PodSandboxStatus| { &mut m.linux },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &PodSandboxStatus| { &m.labels },
                |m: &mut PodSandboxStatus| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &PodSandboxStatus| { &m.annotations },
                |m: &mut PodSandboxStatus| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_handler",
                |m: &PodSandboxStatus| { &m.runtime_handler },
                |m: &mut PodSandboxStatus| { &mut m.runtime_handler },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxStatus>(
                "PodSandboxStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxStatus {
        static instance: ::protobuf::rt::LazyV2<PodSandboxStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxStatus::new)
    }
}

impl ::protobuf::Clear for PodSandboxStatus {
    fn clear(&mut self) {
        self.id.clear();
        self.metadata.clear();
        self.state = PodSandboxState::SANDBOX_READY;
        self.created_at = 0;
        self.network.clear();
        self.linux.clear();
        self.labels.clear();
        self.annotations.clear();
        self.runtime_handler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxStatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<PodSandboxStatus>,
    pub info: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxStatusResponse {
    fn default() -> &'a PodSandboxStatusResponse {
        <PodSandboxStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxStatusResponse {
    pub fn new() -> PodSandboxStatusResponse {
        ::std::default::Default::default()
    }

    // .runtime.v1.PodSandboxStatus status = 1;


    pub fn get_status(&self) -> &PodSandboxStatus {
        self.status.as_ref().unwrap_or_else(|| <PodSandboxStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodSandboxStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodSandboxStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PodSandboxStatus {
        self.status.take().unwrap_or_else(|| PodSandboxStatus::new())
    }

    // repeated .runtime.v1.PodSandboxStatusResponse.InfoEntry info = 2;


    pub fn get_info(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.info, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PodSandboxStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxStatusResponse {
        PodSandboxStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxStatus>>(
                "status",
                |m: &PodSandboxStatusResponse| { &m.status },
                |m: &mut PodSandboxStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &PodSandboxStatusResponse| { &m.info },
                |m: &mut PodSandboxStatusResponse| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxStatusResponse>(
                "PodSandboxStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxStatusResponse {
        static instance: ::protobuf::rt::LazyV2<PodSandboxStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxStatusResponse::new)
    }
}

impl ::protobuf::Clear for PodSandboxStatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxStateValue {
    // message fields
    pub state: PodSandboxState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxStateValue {
    fn default() -> &'a PodSandboxStateValue {
        <PodSandboxStateValue as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxStateValue {
    pub fn new() -> PodSandboxStateValue {
        ::std::default::Default::default()
    }

    // .runtime.v1.PodSandboxState state = 1;


    pub fn get_state(&self) -> PodSandboxState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PodSandboxState::SANDBOX_READY;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PodSandboxState) {
        self.state = v;
    }
}

impl ::protobuf::Message for PodSandboxStateValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != PodSandboxState::SANDBOX_READY {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != PodSandboxState::SANDBOX_READY {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxStateValue {
        PodSandboxStateValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PodSandboxState>>(
                "state",
                |m: &PodSandboxStateValue| { &m.state },
                |m: &mut PodSandboxStateValue| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxStateValue>(
                "PodSandboxStateValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxStateValue {
        static instance: ::protobuf::rt::LazyV2<PodSandboxStateValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxStateValue::new)
    }
}

impl ::protobuf::Clear for PodSandboxStateValue {
    fn clear(&mut self) {
        self.state = PodSandboxState::SANDBOX_READY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxStateValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxStateValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandboxFilter {
    // message fields
    pub id: ::std::string::String,
    pub state: ::protobuf::SingularPtrField<PodSandboxStateValue>,
    pub label_selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandboxFilter {
    fn default() -> &'a PodSandboxFilter {
        <PodSandboxFilter as ::protobuf::Message>::default_instance()
    }
}

impl PodSandboxFilter {
    pub fn new() -> PodSandboxFilter {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.PodSandboxStateValue state = 2;


    pub fn get_state(&self) -> &PodSandboxStateValue {
        self.state.as_ref().unwrap_or_else(|| <PodSandboxStateValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PodSandboxStateValue) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut PodSandboxStateValue {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> PodSandboxStateValue {
        self.state.take().unwrap_or_else(|| PodSandboxStateValue::new())
    }

    // repeated .runtime.v1.PodSandboxFilter.LabelSelectorEntry label_selector = 3;


    pub fn get_label_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.label_selector
    }
    pub fn clear_label_selector(&mut self) {
        self.label_selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.label_selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.label_selector
    }

    // Take field
    pub fn take_label_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.label_selector, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PodSandboxFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.label_selector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.label_selector);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.label_selector, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandboxFilter {
        PodSandboxFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PodSandboxFilter| { &m.id },
                |m: &mut PodSandboxFilter| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxStateValue>>(
                "state",
                |m: &PodSandboxFilter| { &m.state },
                |m: &mut PodSandboxFilter| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "label_selector",
                |m: &PodSandboxFilter| { &m.label_selector },
                |m: &mut PodSandboxFilter| { &mut m.label_selector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandboxFilter>(
                "PodSandboxFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandboxFilter {
        static instance: ::protobuf::rt::LazyV2<PodSandboxFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandboxFilter::new)
    }
}

impl ::protobuf::Clear for PodSandboxFilter {
    fn clear(&mut self) {
        self.id.clear();
        self.state.clear();
        self.label_selector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandboxFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPodSandboxRequest {
    // message fields
    pub filter: ::protobuf::SingularPtrField<PodSandboxFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPodSandboxRequest {
    fn default() -> &'a ListPodSandboxRequest {
        <ListPodSandboxRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPodSandboxRequest {
    pub fn new() -> ListPodSandboxRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.PodSandboxFilter filter = 1;


    pub fn get_filter(&self) -> &PodSandboxFilter {
        self.filter.as_ref().unwrap_or_else(|| <PodSandboxFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: PodSandboxFilter) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut PodSandboxFilter {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> PodSandboxFilter {
        self.filter.take().unwrap_or_else(|| PodSandboxFilter::new())
    }
}

impl ::protobuf::Message for ListPodSandboxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPodSandboxRequest {
        ListPodSandboxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxFilter>>(
                "filter",
                |m: &ListPodSandboxRequest| { &m.filter },
                |m: &mut ListPodSandboxRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPodSandboxRequest>(
                "ListPodSandboxRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPodSandboxRequest {
        static instance: ::protobuf::rt::LazyV2<ListPodSandboxRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPodSandboxRequest::new)
    }
}

impl ::protobuf::Clear for ListPodSandboxRequest {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPodSandboxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPodSandboxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSandbox {
    // message fields
    pub id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<PodSandboxMetadata>,
    pub state: PodSandboxState,
    pub created_at: i64,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub runtime_handler: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSandbox {
    fn default() -> &'a PodSandbox {
        <PodSandbox as ::protobuf::Message>::default_instance()
    }
}

impl PodSandbox {
    pub fn new() -> PodSandbox {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.PodSandboxMetadata metadata = 2;


    pub fn get_metadata(&self) -> &PodSandboxMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <PodSandboxMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: PodSandboxMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut PodSandboxMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> PodSandboxMetadata {
        self.metadata.take().unwrap_or_else(|| PodSandboxMetadata::new())
    }

    // .runtime.v1.PodSandboxState state = 3;


    pub fn get_state(&self) -> PodSandboxState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PodSandboxState::SANDBOX_READY;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PodSandboxState) {
        self.state = v;
    }

    // int64 created_at = 4;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // repeated .runtime.v1.PodSandbox.LabelsEntry labels = 5;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.PodSandbox.AnnotationsEntry annotations = 6;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // string runtime_handler = 7;


    pub fn get_runtime_handler(&self) -> &str {
        &self.runtime_handler
    }
    pub fn clear_runtime_handler(&mut self) {
        self.runtime_handler.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_handler(&mut self, v: ::std::string::String) {
        self.runtime_handler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_handler(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_handler
    }

    // Take field
    pub fn take_runtime_handler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_handler, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodSandbox {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_at = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_handler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != PodSandboxState::SANDBOX_READY {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.annotations);
        if !self.runtime_handler.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.runtime_handler);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != PodSandboxState::SANDBOX_READY {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.created_at != 0 {
            os.write_int64(4, self.created_at)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.annotations, os)?;
        if !self.runtime_handler.is_empty() {
            os.write_string(7, &self.runtime_handler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSandbox {
        PodSandbox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PodSandbox| { &m.id },
                |m: &mut PodSandbox| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxMetadata>>(
                "metadata",
                |m: &PodSandbox| { &m.metadata },
                |m: &mut PodSandbox| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PodSandboxState>>(
                "state",
                |m: &PodSandbox| { &m.state },
                |m: &mut PodSandbox| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "created_at",
                |m: &PodSandbox| { &m.created_at },
                |m: &mut PodSandbox| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &PodSandbox| { &m.labels },
                |m: &mut PodSandbox| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &PodSandbox| { &m.annotations },
                |m: &mut PodSandbox| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_handler",
                |m: &PodSandbox| { &m.runtime_handler },
                |m: &mut PodSandbox| { &mut m.runtime_handler },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSandbox>(
                "PodSandbox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSandbox {
        static instance: ::protobuf::rt::LazyV2<PodSandbox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSandbox::new)
    }
}

impl ::protobuf::Clear for PodSandbox {
    fn clear(&mut self) {
        self.id.clear();
        self.metadata.clear();
        self.state = PodSandboxState::SANDBOX_READY;
        self.created_at = 0;
        self.labels.clear();
        self.annotations.clear();
        self.runtime_handler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSandbox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandbox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPodSandboxResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<PodSandbox>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPodSandboxResponse {
    fn default() -> &'a ListPodSandboxResponse {
        <ListPodSandboxResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPodSandboxResponse {
    pub fn new() -> ListPodSandboxResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.PodSandbox items = 1;


    pub fn get_items(&self) -> &[PodSandbox] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PodSandbox>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PodSandbox> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PodSandbox> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPodSandboxResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPodSandboxResponse {
        ListPodSandboxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandbox>>(
                "items",
                |m: &ListPodSandboxResponse| { &m.items },
                |m: &mut ListPodSandboxResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListPodSandboxResponse>(
                "ListPodSandboxResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListPodSandboxResponse {
        static instance: ::protobuf::rt::LazyV2<ListPodSandboxResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListPodSandboxResponse::new)
    }
}

impl ::protobuf::Clear for ListPodSandboxResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPodSandboxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPodSandboxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageSpec {
    // message fields
    pub image: ::std::string::String,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageSpec {
    fn default() -> &'a ImageSpec {
        <ImageSpec as ::protobuf::Message>::default_instance()
    }
}

impl ImageSpec {
    pub fn new() -> ImageSpec {
        ::std::default::Default::default()
    }

    // string image = 1;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // repeated .runtime.v1.ImageSpec.AnnotationsEntry annotations = 2;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ImageSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.image);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.annotations);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image.is_empty() {
            os.write_string(1, &self.image)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.annotations, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageSpec {
        ImageSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &ImageSpec| { &m.image },
                |m: &mut ImageSpec| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ImageSpec| { &m.annotations },
                |m: &mut ImageSpec| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageSpec>(
                "ImageSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageSpec {
        static instance: ::protobuf::rt::LazyV2<ImageSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageSpec::new)
    }
}

impl ::protobuf::Clear for ImageSpec {
    fn clear(&mut self) {
        self.image.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValue {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValue {
    fn default() -> &'a KeyValue {
        <KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyValue| { &m.key },
                |m: &mut KeyValue| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &KeyValue| { &m.value },
                |m: &mut KeyValue| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValue>(
                "KeyValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValue {
        static instance: ::protobuf::rt::LazyV2<KeyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValue::new)
    }
}

impl ::protobuf::Clear for KeyValue {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxContainerResources {
    // message fields
    pub cpu_period: i64,
    pub cpu_quota: i64,
    pub cpu_shares: i64,
    pub memory_limit_in_bytes: i64,
    pub oom_score_adj: i64,
    pub cpuset_cpus: ::std::string::String,
    pub cpuset_mems: ::std::string::String,
    pub hugepage_limits: ::protobuf::RepeatedField<HugepageLimit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxContainerResources {
    fn default() -> &'a LinuxContainerResources {
        <LinuxContainerResources as ::protobuf::Message>::default_instance()
    }
}

impl LinuxContainerResources {
    pub fn new() -> LinuxContainerResources {
        ::std::default::Default::default()
    }

    // int64 cpu_period = 1;


    pub fn get_cpu_period(&self) -> i64 {
        self.cpu_period
    }
    pub fn clear_cpu_period(&mut self) {
        self.cpu_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_period(&mut self, v: i64) {
        self.cpu_period = v;
    }

    // int64 cpu_quota = 2;


    pub fn get_cpu_quota(&self) -> i64 {
        self.cpu_quota
    }
    pub fn clear_cpu_quota(&mut self) {
        self.cpu_quota = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_quota(&mut self, v: i64) {
        self.cpu_quota = v;
    }

    // int64 cpu_shares = 3;


    pub fn get_cpu_shares(&self) -> i64 {
        self.cpu_shares
    }
    pub fn clear_cpu_shares(&mut self) {
        self.cpu_shares = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_shares(&mut self, v: i64) {
        self.cpu_shares = v;
    }

    // int64 memory_limit_in_bytes = 4;


    pub fn get_memory_limit_in_bytes(&self) -> i64 {
        self.memory_limit_in_bytes
    }
    pub fn clear_memory_limit_in_bytes(&mut self) {
        self.memory_limit_in_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_limit_in_bytes(&mut self, v: i64) {
        self.memory_limit_in_bytes = v;
    }

    // int64 oom_score_adj = 5;


    pub fn get_oom_score_adj(&self) -> i64 {
        self.oom_score_adj
    }
    pub fn clear_oom_score_adj(&mut self) {
        self.oom_score_adj = 0;
    }

    // Param is passed by value, moved
    pub fn set_oom_score_adj(&mut self, v: i64) {
        self.oom_score_adj = v;
    }

    // string cpuset_cpus = 6;


    pub fn get_cpuset_cpus(&self) -> &str {
        &self.cpuset_cpus
    }
    pub fn clear_cpuset_cpus(&mut self) {
        self.cpuset_cpus.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpuset_cpus(&mut self, v: ::std::string::String) {
        self.cpuset_cpus = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpuset_cpus(&mut self) -> &mut ::std::string::String {
        &mut self.cpuset_cpus
    }

    // Take field
    pub fn take_cpuset_cpus(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cpuset_cpus, ::std::string::String::new())
    }

    // string cpuset_mems = 7;


    pub fn get_cpuset_mems(&self) -> &str {
        &self.cpuset_mems
    }
    pub fn clear_cpuset_mems(&mut self) {
        self.cpuset_mems.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpuset_mems(&mut self, v: ::std::string::String) {
        self.cpuset_mems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpuset_mems(&mut self) -> &mut ::std::string::String {
        &mut self.cpuset_mems
    }

    // Take field
    pub fn take_cpuset_mems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cpuset_mems, ::std::string::String::new())
    }

    // repeated .runtime.v1.HugepageLimit hugepage_limits = 8;


    pub fn get_hugepage_limits(&self) -> &[HugepageLimit] {
        &self.hugepage_limits
    }
    pub fn clear_hugepage_limits(&mut self) {
        self.hugepage_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugepage_limits(&mut self, v: ::protobuf::RepeatedField<HugepageLimit>) {
        self.hugepage_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugepage_limits(&mut self) -> &mut ::protobuf::RepeatedField<HugepageLimit> {
        &mut self.hugepage_limits
    }

    // Take field
    pub fn take_hugepage_limits(&mut self) -> ::protobuf::RepeatedField<HugepageLimit> {
        ::std::mem::replace(&mut self.hugepage_limits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinuxContainerResources {
    fn is_initialized(&self) -> bool {
        for v in &self.hugepage_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_period = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_quota = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_shares = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_limit_in_bytes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.oom_score_adj = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cpuset_cpus)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cpuset_mems)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hugepage_limits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpu_period != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cpu_period, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_quota != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cpu_quota, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_shares != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cpu_shares, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory_limit_in_bytes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.memory_limit_in_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oom_score_adj != 0 {
            my_size += ::protobuf::rt::value_size(5, self.oom_score_adj, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cpuset_cpus.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cpuset_cpus);
        }
        if !self.cpuset_mems.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.cpuset_mems);
        }
        for value in &self.hugepage_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cpu_period != 0 {
            os.write_int64(1, self.cpu_period)?;
        }
        if self.cpu_quota != 0 {
            os.write_int64(2, self.cpu_quota)?;
        }
        if self.cpu_shares != 0 {
            os.write_int64(3, self.cpu_shares)?;
        }
        if self.memory_limit_in_bytes != 0 {
            os.write_int64(4, self.memory_limit_in_bytes)?;
        }
        if self.oom_score_adj != 0 {
            os.write_int64(5, self.oom_score_adj)?;
        }
        if !self.cpuset_cpus.is_empty() {
            os.write_string(6, &self.cpuset_cpus)?;
        }
        if !self.cpuset_mems.is_empty() {
            os.write_string(7, &self.cpuset_mems)?;
        }
        for v in &self.hugepage_limits {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxContainerResources {
        LinuxContainerResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_period",
                |m: &LinuxContainerResources| { &m.cpu_period },
                |m: &mut LinuxContainerResources| { &mut m.cpu_period },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_quota",
                |m: &LinuxContainerResources| { &m.cpu_quota },
                |m: &mut LinuxContainerResources| { &mut m.cpu_quota },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_shares",
                |m: &LinuxContainerResources| { &m.cpu_shares },
                |m: &mut LinuxContainerResources| { &mut m.cpu_shares },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "memory_limit_in_bytes",
                |m: &LinuxContainerResources| { &m.memory_limit_in_bytes },
                |m: &mut LinuxContainerResources| { &mut m.memory_limit_in_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "oom_score_adj",
                |m: &LinuxContainerResources| { &m.oom_score_adj },
                |m: &mut LinuxContainerResources| { &mut m.oom_score_adj },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cpuset_cpus",
                |m: &LinuxContainerResources| { &m.cpuset_cpus },
                |m: &mut LinuxContainerResources| { &mut m.cpuset_cpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cpuset_mems",
                |m: &LinuxContainerResources| { &m.cpuset_mems },
                |m: &mut LinuxContainerResources| { &mut m.cpuset_mems },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HugepageLimit>>(
                "hugepage_limits",
                |m: &LinuxContainerResources| { &m.hugepage_limits },
                |m: &mut LinuxContainerResources| { &mut m.hugepage_limits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxContainerResources>(
                "LinuxContainerResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxContainerResources {
        static instance: ::protobuf::rt::LazyV2<LinuxContainerResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxContainerResources::new)
    }
}

impl ::protobuf::Clear for LinuxContainerResources {
    fn clear(&mut self) {
        self.cpu_period = 0;
        self.cpu_quota = 0;
        self.cpu_shares = 0;
        self.memory_limit_in_bytes = 0;
        self.oom_score_adj = 0;
        self.cpuset_cpus.clear();
        self.cpuset_mems.clear();
        self.hugepage_limits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxContainerResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxContainerResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HugepageLimit {
    // message fields
    pub page_size: ::std::string::String,
    pub limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HugepageLimit {
    fn default() -> &'a HugepageLimit {
        <HugepageLimit as ::protobuf::Message>::default_instance()
    }
}

impl HugepageLimit {
    pub fn new() -> HugepageLimit {
        ::std::default::Default::default()
    }

    // string page_size = 1;


    pub fn get_page_size(&self) -> &str {
        &self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: ::std::string::String) {
        self.page_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_size(&mut self) -> &mut ::std::string::String {
        &mut self.page_size
    }

    // Take field
    pub fn take_page_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_size, ::std::string::String::new())
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for HugepageLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_size)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.page_size.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.page_size);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.page_size.is_empty() {
            os.write_string(1, &self.page_size)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HugepageLimit {
        HugepageLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_size",
                |m: &HugepageLimit| { &m.page_size },
                |m: &mut HugepageLimit| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "limit",
                |m: &HugepageLimit| { &m.limit },
                |m: &mut HugepageLimit| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HugepageLimit>(
                "HugepageLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HugepageLimit {
        static instance: ::protobuf::rt::LazyV2<HugepageLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HugepageLimit::new)
    }
}

impl ::protobuf::Clear for HugepageLimit {
    fn clear(&mut self) {
        self.page_size.clear();
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HugepageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugepageLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SELinuxOption {
    // message fields
    pub user: ::std::string::String,
    pub role: ::std::string::String,
    pub field_type: ::std::string::String,
    pub level: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SELinuxOption {
    fn default() -> &'a SELinuxOption {
        <SELinuxOption as ::protobuf::Message>::default_instance()
    }
}

impl SELinuxOption {
    pub fn new() -> SELinuxOption {
        ::std::default::Default::default()
    }

    // string user = 1;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // string role = 2;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string level = 4;


    pub fn get_level(&self) -> &str {
        &self.level
    }
    pub fn clear_level(&mut self) {
        self.level.clear();
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        &mut self.level
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SELinuxOption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user);
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.role);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if !self.level.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user.is_empty() {
            os.write_string(1, &self.user)?;
        }
        if !self.role.is_empty() {
            os.write_string(2, &self.role)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if !self.level.is_empty() {
            os.write_string(4, &self.level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SELinuxOption {
        SELinuxOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &SELinuxOption| { &m.user },
                |m: &mut SELinuxOption| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &SELinuxOption| { &m.role },
                |m: &mut SELinuxOption| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &SELinuxOption| { &m.field_type },
                |m: &mut SELinuxOption| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level",
                |m: &SELinuxOption| { &m.level },
                |m: &mut SELinuxOption| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SELinuxOption>(
                "SELinuxOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SELinuxOption {
        static instance: ::protobuf::rt::LazyV2<SELinuxOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SELinuxOption::new)
    }
}

impl ::protobuf::Clear for SELinuxOption {
    fn clear(&mut self) {
        self.user.clear();
        self.role.clear();
        self.field_type.clear();
        self.level.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SELinuxOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SELinuxOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Capability {
    // message fields
    pub add_capabilities: ::protobuf::RepeatedField<::std::string::String>,
    pub drop_capabilities: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Capability {
    fn default() -> &'a Capability {
        <Capability as ::protobuf::Message>::default_instance()
    }
}

impl Capability {
    pub fn new() -> Capability {
        ::std::default::Default::default()
    }

    // repeated string add_capabilities = 1;


    pub fn get_add_capabilities(&self) -> &[::std::string::String] {
        &self.add_capabilities
    }
    pub fn clear_add_capabilities(&mut self) {
        self.add_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_add_capabilities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.add_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add_capabilities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.add_capabilities
    }

    // Take field
    pub fn take_add_capabilities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.add_capabilities, ::protobuf::RepeatedField::new())
    }

    // repeated string drop_capabilities = 2;


    pub fn get_drop_capabilities(&self) -> &[::std::string::String] {
        &self.drop_capabilities
    }
    pub fn clear_drop_capabilities(&mut self) {
        self.drop_capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_drop_capabilities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.drop_capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drop_capabilities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drop_capabilities
    }

    // Take field
    pub fn take_drop_capabilities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.drop_capabilities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Capability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.add_capabilities)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.drop_capabilities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.add_capabilities {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.drop_capabilities {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.add_capabilities {
            os.write_string(1, &v)?;
        };
        for v in &self.drop_capabilities {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Capability {
        Capability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "add_capabilities",
                |m: &Capability| { &m.add_capabilities },
                |m: &mut Capability| { &mut m.add_capabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "drop_capabilities",
                |m: &Capability| { &m.drop_capabilities },
                |m: &mut Capability| { &mut m.drop_capabilities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Capability>(
                "Capability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Capability {
        static instance: ::protobuf::rt::LazyV2<Capability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Capability::new)
    }
}

impl ::protobuf::Clear for Capability {
    fn clear(&mut self) {
        self.add_capabilities.clear();
        self.drop_capabilities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxContainerSecurityContext {
    // message fields
    pub capabilities: ::protobuf::SingularPtrField<Capability>,
    pub privileged: bool,
    pub namespace_options: ::protobuf::SingularPtrField<NamespaceOption>,
    pub selinux_options: ::protobuf::SingularPtrField<SELinuxOption>,
    pub run_as_user: ::protobuf::SingularPtrField<Int64Value>,
    pub run_as_group: ::protobuf::SingularPtrField<Int64Value>,
    pub run_as_username: ::std::string::String,
    pub readonly_rootfs: bool,
    pub supplemental_groups: ::std::vec::Vec<i64>,
    pub no_new_privs: bool,
    pub masked_paths: ::protobuf::RepeatedField<::std::string::String>,
    pub readonly_paths: ::protobuf::RepeatedField<::std::string::String>,
    pub seccomp: ::protobuf::SingularPtrField<SecurityProfile>,
    pub apparmor: ::protobuf::SingularPtrField<SecurityProfile>,
    pub apparmor_profile: ::std::string::String,
    pub seccomp_profile_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxContainerSecurityContext {
    fn default() -> &'a LinuxContainerSecurityContext {
        <LinuxContainerSecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl LinuxContainerSecurityContext {
    pub fn new() -> LinuxContainerSecurityContext {
        ::std::default::Default::default()
    }

    // .runtime.v1.Capability capabilities = 1;


    pub fn get_capabilities(&self) -> &Capability {
        self.capabilities.as_ref().unwrap_or_else(|| <Capability as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: Capability) {
        self.capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capabilities(&mut self) -> &mut Capability {
        if self.capabilities.is_none() {
            self.capabilities.set_default();
        }
        self.capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_capabilities(&mut self) -> Capability {
        self.capabilities.take().unwrap_or_else(|| Capability::new())
    }

    // bool privileged = 2;


    pub fn get_privileged(&self) -> bool {
        self.privileged
    }
    pub fn clear_privileged(&mut self) {
        self.privileged = false;
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = v;
    }

    // .runtime.v1.NamespaceOption namespace_options = 3;


    pub fn get_namespace_options(&self) -> &NamespaceOption {
        self.namespace_options.as_ref().unwrap_or_else(|| <NamespaceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namespace_options(&mut self) {
        self.namespace_options.clear();
    }

    pub fn has_namespace_options(&self) -> bool {
        self.namespace_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace_options(&mut self, v: NamespaceOption) {
        self.namespace_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace_options(&mut self) -> &mut NamespaceOption {
        if self.namespace_options.is_none() {
            self.namespace_options.set_default();
        }
        self.namespace_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace_options(&mut self) -> NamespaceOption {
        self.namespace_options.take().unwrap_or_else(|| NamespaceOption::new())
    }

    // .runtime.v1.SELinuxOption selinux_options = 4;


    pub fn get_selinux_options(&self) -> &SELinuxOption {
        self.selinux_options.as_ref().unwrap_or_else(|| <SELinuxOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selinux_options(&mut self) {
        self.selinux_options.clear();
    }

    pub fn has_selinux_options(&self) -> bool {
        self.selinux_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selinux_options(&mut self, v: SELinuxOption) {
        self.selinux_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selinux_options(&mut self) -> &mut SELinuxOption {
        if self.selinux_options.is_none() {
            self.selinux_options.set_default();
        }
        self.selinux_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_selinux_options(&mut self) -> SELinuxOption {
        self.selinux_options.take().unwrap_or_else(|| SELinuxOption::new())
    }

    // .runtime.v1.Int64Value run_as_user = 5;


    pub fn get_run_as_user(&self) -> &Int64Value {
        self.run_as_user.as_ref().unwrap_or_else(|| <Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_run_as_user(&mut self) {
        self.run_as_user.clear();
    }

    pub fn has_run_as_user(&self) -> bool {
        self.run_as_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_as_user(&mut self, v: Int64Value) {
        self.run_as_user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_user(&mut self) -> &mut Int64Value {
        if self.run_as_user.is_none() {
            self.run_as_user.set_default();
        }
        self.run_as_user.as_mut().unwrap()
    }

    // Take field
    pub fn take_run_as_user(&mut self) -> Int64Value {
        self.run_as_user.take().unwrap_or_else(|| Int64Value::new())
    }

    // .runtime.v1.Int64Value run_as_group = 12;


    pub fn get_run_as_group(&self) -> &Int64Value {
        self.run_as_group.as_ref().unwrap_or_else(|| <Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_run_as_group(&mut self) {
        self.run_as_group.clear();
    }

    pub fn has_run_as_group(&self) -> bool {
        self.run_as_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_as_group(&mut self, v: Int64Value) {
        self.run_as_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_group(&mut self) -> &mut Int64Value {
        if self.run_as_group.is_none() {
            self.run_as_group.set_default();
        }
        self.run_as_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_run_as_group(&mut self) -> Int64Value {
        self.run_as_group.take().unwrap_or_else(|| Int64Value::new())
    }

    // string run_as_username = 6;


    pub fn get_run_as_username(&self) -> &str {
        &self.run_as_username
    }
    pub fn clear_run_as_username(&mut self) {
        self.run_as_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_run_as_username(&mut self, v: ::std::string::String) {
        self.run_as_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_username(&mut self) -> &mut ::std::string::String {
        &mut self.run_as_username
    }

    // Take field
    pub fn take_run_as_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.run_as_username, ::std::string::String::new())
    }

    // bool readonly_rootfs = 7;


    pub fn get_readonly_rootfs(&self) -> bool {
        self.readonly_rootfs
    }
    pub fn clear_readonly_rootfs(&mut self) {
        self.readonly_rootfs = false;
    }

    // Param is passed by value, moved
    pub fn set_readonly_rootfs(&mut self, v: bool) {
        self.readonly_rootfs = v;
    }

    // repeated int64 supplemental_groups = 8;


    pub fn get_supplemental_groups(&self) -> &[i64] {
        &self.supplemental_groups
    }
    pub fn clear_supplemental_groups(&mut self) {
        self.supplemental_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplemental_groups(&mut self, v: ::std::vec::Vec<i64>) {
        self.supplemental_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supplemental_groups(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplemental_groups
    }

    // Take field
    pub fn take_supplemental_groups(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.supplemental_groups, ::std::vec::Vec::new())
    }

    // bool no_new_privs = 11;


    pub fn get_no_new_privs(&self) -> bool {
        self.no_new_privs
    }
    pub fn clear_no_new_privs(&mut self) {
        self.no_new_privs = false;
    }

    // Param is passed by value, moved
    pub fn set_no_new_privs(&mut self, v: bool) {
        self.no_new_privs = v;
    }

    // repeated string masked_paths = 13;


    pub fn get_masked_paths(&self) -> &[::std::string::String] {
        &self.masked_paths
    }
    pub fn clear_masked_paths(&mut self) {
        self.masked_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_masked_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.masked_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_masked_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.masked_paths
    }

    // Take field
    pub fn take_masked_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.masked_paths, ::protobuf::RepeatedField::new())
    }

    // repeated string readonly_paths = 14;


    pub fn get_readonly_paths(&self) -> &[::std::string::String] {
        &self.readonly_paths
    }
    pub fn clear_readonly_paths(&mut self) {
        self.readonly_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_readonly_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.readonly_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_readonly_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.readonly_paths
    }

    // Take field
    pub fn take_readonly_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.readonly_paths, ::protobuf::RepeatedField::new())
    }

    // .runtime.v1.SecurityProfile seccomp = 15;


    pub fn get_seccomp(&self) -> &SecurityProfile {
        self.seccomp.as_ref().unwrap_or_else(|| <SecurityProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seccomp(&mut self) {
        self.seccomp.clear();
    }

    pub fn has_seccomp(&self) -> bool {
        self.seccomp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccomp(&mut self, v: SecurityProfile) {
        self.seccomp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccomp(&mut self) -> &mut SecurityProfile {
        if self.seccomp.is_none() {
            self.seccomp.set_default();
        }
        self.seccomp.as_mut().unwrap()
    }

    // Take field
    pub fn take_seccomp(&mut self) -> SecurityProfile {
        self.seccomp.take().unwrap_or_else(|| SecurityProfile::new())
    }

    // .runtime.v1.SecurityProfile apparmor = 16;


    pub fn get_apparmor(&self) -> &SecurityProfile {
        self.apparmor.as_ref().unwrap_or_else(|| <SecurityProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apparmor(&mut self) {
        self.apparmor.clear();
    }

    pub fn has_apparmor(&self) -> bool {
        self.apparmor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apparmor(&mut self, v: SecurityProfile) {
        self.apparmor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apparmor(&mut self) -> &mut SecurityProfile {
        if self.apparmor.is_none() {
            self.apparmor.set_default();
        }
        self.apparmor.as_mut().unwrap()
    }

    // Take field
    pub fn take_apparmor(&mut self) -> SecurityProfile {
        self.apparmor.take().unwrap_or_else(|| SecurityProfile::new())
    }

    // string apparmor_profile = 9;


    pub fn get_apparmor_profile(&self) -> &str {
        &self.apparmor_profile
    }
    pub fn clear_apparmor_profile(&mut self) {
        self.apparmor_profile.clear();
    }

    // Param is passed by value, moved
    pub fn set_apparmor_profile(&mut self, v: ::std::string::String) {
        self.apparmor_profile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apparmor_profile(&mut self) -> &mut ::std::string::String {
        &mut self.apparmor_profile
    }

    // Take field
    pub fn take_apparmor_profile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.apparmor_profile, ::std::string::String::new())
    }

    // string seccomp_profile_path = 10;


    pub fn get_seccomp_profile_path(&self) -> &str {
        &self.seccomp_profile_path
    }
    pub fn clear_seccomp_profile_path(&mut self) {
        self.seccomp_profile_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_seccomp_profile_path(&mut self, v: ::std::string::String) {
        self.seccomp_profile_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccomp_profile_path(&mut self) -> &mut ::std::string::String {
        &mut self.seccomp_profile_path
    }

    // Take field
    pub fn take_seccomp_profile_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seccomp_profile_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LinuxContainerSecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.namespace_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selinux_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.run_as_user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.run_as_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seccomp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apparmor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capabilities)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namespace_options)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selinux_options)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.run_as_user)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.run_as_group)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.run_as_username)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readonly_rootfs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.supplemental_groups)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_new_privs = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.masked_paths)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.readonly_paths)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seccomp)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apparmor)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.apparmor_profile)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seccomp_profile_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.privileged != false {
            my_size += 2;
        }
        if let Some(ref v) = self.namespace_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selinux_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.run_as_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.run_as_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.run_as_username.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.run_as_username);
        }
        if self.readonly_rootfs != false {
            my_size += 2;
        }
        for value in &self.supplemental_groups {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.no_new_privs != false {
            my_size += 2;
        }
        for value in &self.masked_paths {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.readonly_paths {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if let Some(ref v) = self.seccomp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apparmor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.apparmor_profile.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.apparmor_profile);
        }
        if !self.seccomp_profile_path.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.seccomp_profile_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capabilities.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.privileged != false {
            os.write_bool(2, self.privileged)?;
        }
        if let Some(ref v) = self.namespace_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selinux_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.run_as_user.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.run_as_group.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.run_as_username.is_empty() {
            os.write_string(6, &self.run_as_username)?;
        }
        if self.readonly_rootfs != false {
            os.write_bool(7, self.readonly_rootfs)?;
        }
        for v in &self.supplemental_groups {
            os.write_int64(8, *v)?;
        };
        if self.no_new_privs != false {
            os.write_bool(11, self.no_new_privs)?;
        }
        for v in &self.masked_paths {
            os.write_string(13, &v)?;
        };
        for v in &self.readonly_paths {
            os.write_string(14, &v)?;
        };
        if let Some(ref v) = self.seccomp.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apparmor.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.apparmor_profile.is_empty() {
            os.write_string(9, &self.apparmor_profile)?;
        }
        if !self.seccomp_profile_path.is_empty() {
            os.write_string(10, &self.seccomp_profile_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxContainerSecurityContext {
        LinuxContainerSecurityContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Capability>>(
                "capabilities",
                |m: &LinuxContainerSecurityContext| { &m.capabilities },
                |m: &mut LinuxContainerSecurityContext| { &mut m.capabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "privileged",
                |m: &LinuxContainerSecurityContext| { &m.privileged },
                |m: &mut LinuxContainerSecurityContext| { &mut m.privileged },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceOption>>(
                "namespace_options",
                |m: &LinuxContainerSecurityContext| { &m.namespace_options },
                |m: &mut LinuxContainerSecurityContext| { &mut m.namespace_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOption>>(
                "selinux_options",
                |m: &LinuxContainerSecurityContext| { &m.selinux_options },
                |m: &mut LinuxContainerSecurityContext| { &mut m.selinux_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Int64Value>>(
                "run_as_user",
                |m: &LinuxContainerSecurityContext| { &m.run_as_user },
                |m: &mut LinuxContainerSecurityContext| { &mut m.run_as_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Int64Value>>(
                "run_as_group",
                |m: &LinuxContainerSecurityContext| { &m.run_as_group },
                |m: &mut LinuxContainerSecurityContext| { &mut m.run_as_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "run_as_username",
                |m: &LinuxContainerSecurityContext| { &m.run_as_username },
                |m: &mut LinuxContainerSecurityContext| { &mut m.run_as_username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readonly_rootfs",
                |m: &LinuxContainerSecurityContext| { &m.readonly_rootfs },
                |m: &mut LinuxContainerSecurityContext| { &mut m.readonly_rootfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "supplemental_groups",
                |m: &LinuxContainerSecurityContext| { &m.supplemental_groups },
                |m: &mut LinuxContainerSecurityContext| { &mut m.supplemental_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_new_privs",
                |m: &LinuxContainerSecurityContext| { &m.no_new_privs },
                |m: &mut LinuxContainerSecurityContext| { &mut m.no_new_privs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "masked_paths",
                |m: &LinuxContainerSecurityContext| { &m.masked_paths },
                |m: &mut LinuxContainerSecurityContext| { &mut m.masked_paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "readonly_paths",
                |m: &LinuxContainerSecurityContext| { &m.readonly_paths },
                |m: &mut LinuxContainerSecurityContext| { &mut m.readonly_paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityProfile>>(
                "seccomp",
                |m: &LinuxContainerSecurityContext| { &m.seccomp },
                |m: &mut LinuxContainerSecurityContext| { &mut m.seccomp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityProfile>>(
                "apparmor",
                |m: &LinuxContainerSecurityContext| { &m.apparmor },
                |m: &mut LinuxContainerSecurityContext| { &mut m.apparmor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apparmor_profile",
                |m: &LinuxContainerSecurityContext| { &m.apparmor_profile },
                |m: &mut LinuxContainerSecurityContext| { &mut m.apparmor_profile },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seccomp_profile_path",
                |m: &LinuxContainerSecurityContext| { &m.seccomp_profile_path },
                |m: &mut LinuxContainerSecurityContext| { &mut m.seccomp_profile_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxContainerSecurityContext>(
                "LinuxContainerSecurityContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxContainerSecurityContext {
        static instance: ::protobuf::rt::LazyV2<LinuxContainerSecurityContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxContainerSecurityContext::new)
    }
}

impl ::protobuf::Clear for LinuxContainerSecurityContext {
    fn clear(&mut self) {
        self.capabilities.clear();
        self.privileged = false;
        self.namespace_options.clear();
        self.selinux_options.clear();
        self.run_as_user.clear();
        self.run_as_group.clear();
        self.run_as_username.clear();
        self.readonly_rootfs = false;
        self.supplemental_groups.clear();
        self.no_new_privs = false;
        self.masked_paths.clear();
        self.readonly_paths.clear();
        self.seccomp.clear();
        self.apparmor.clear();
        self.apparmor_profile.clear();
        self.seccomp_profile_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxContainerSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxContainerSecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinuxContainerConfig {
    // message fields
    pub resources: ::protobuf::SingularPtrField<LinuxContainerResources>,
    pub security_context: ::protobuf::SingularPtrField<LinuxContainerSecurityContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinuxContainerConfig {
    fn default() -> &'a LinuxContainerConfig {
        <LinuxContainerConfig as ::protobuf::Message>::default_instance()
    }
}

impl LinuxContainerConfig {
    pub fn new() -> LinuxContainerConfig {
        ::std::default::Default::default()
    }

    // .runtime.v1.LinuxContainerResources resources = 1;


    pub fn get_resources(&self) -> &LinuxContainerResources {
        self.resources.as_ref().unwrap_or_else(|| <LinuxContainerResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: LinuxContainerResources) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut LinuxContainerResources {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> LinuxContainerResources {
        self.resources.take().unwrap_or_else(|| LinuxContainerResources::new())
    }

    // .runtime.v1.LinuxContainerSecurityContext security_context = 2;


    pub fn get_security_context(&self) -> &LinuxContainerSecurityContext {
        self.security_context.as_ref().unwrap_or_else(|| <LinuxContainerSecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_security_context(&mut self) {
        self.security_context.clear();
    }

    pub fn has_security_context(&self) -> bool {
        self.security_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_context(&mut self, v: LinuxContainerSecurityContext) {
        self.security_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_context(&mut self) -> &mut LinuxContainerSecurityContext {
        if self.security_context.is_none() {
            self.security_context.set_default();
        }
        self.security_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_context(&mut self) -> LinuxContainerSecurityContext {
        self.security_context.take().unwrap_or_else(|| LinuxContainerSecurityContext::new())
    }
}

impl ::protobuf::Message for LinuxContainerConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.security_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.security_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.security_context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinuxContainerConfig {
        LinuxContainerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxContainerResources>>(
                "resources",
                |m: &LinuxContainerConfig| { &m.resources },
                |m: &mut LinuxContainerConfig| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxContainerSecurityContext>>(
                "security_context",
                |m: &LinuxContainerConfig| { &m.security_context },
                |m: &mut LinuxContainerConfig| { &mut m.security_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinuxContainerConfig>(
                "LinuxContainerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinuxContainerConfig {
        static instance: ::protobuf::rt::LazyV2<LinuxContainerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinuxContainerConfig::new)
    }
}

impl ::protobuf::Clear for LinuxContainerConfig {
    fn clear(&mut self) {
        self.resources.clear();
        self.security_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinuxContainerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinuxContainerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsContainerSecurityContext {
    // message fields
    pub run_as_username: ::std::string::String,
    pub credential_spec: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsContainerSecurityContext {
    fn default() -> &'a WindowsContainerSecurityContext {
        <WindowsContainerSecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl WindowsContainerSecurityContext {
    pub fn new() -> WindowsContainerSecurityContext {
        ::std::default::Default::default()
    }

    // string run_as_username = 1;


    pub fn get_run_as_username(&self) -> &str {
        &self.run_as_username
    }
    pub fn clear_run_as_username(&mut self) {
        self.run_as_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_run_as_username(&mut self, v: ::std::string::String) {
        self.run_as_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_as_username(&mut self) -> &mut ::std::string::String {
        &mut self.run_as_username
    }

    // Take field
    pub fn take_run_as_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.run_as_username, ::std::string::String::new())
    }

    // string credential_spec = 2;


    pub fn get_credential_spec(&self) -> &str {
        &self.credential_spec
    }
    pub fn clear_credential_spec(&mut self) {
        self.credential_spec.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_spec(&mut self, v: ::std::string::String) {
        self.credential_spec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_spec(&mut self) -> &mut ::std::string::String {
        &mut self.credential_spec
    }

    // Take field
    pub fn take_credential_spec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.credential_spec, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WindowsContainerSecurityContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.run_as_username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.credential_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.run_as_username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.run_as_username);
        }
        if !self.credential_spec.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.credential_spec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.run_as_username.is_empty() {
            os.write_string(1, &self.run_as_username)?;
        }
        if !self.credential_spec.is_empty() {
            os.write_string(2, &self.credential_spec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsContainerSecurityContext {
        WindowsContainerSecurityContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "run_as_username",
                |m: &WindowsContainerSecurityContext| { &m.run_as_username },
                |m: &mut WindowsContainerSecurityContext| { &mut m.run_as_username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential_spec",
                |m: &WindowsContainerSecurityContext| { &m.credential_spec },
                |m: &mut WindowsContainerSecurityContext| { &mut m.credential_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsContainerSecurityContext>(
                "WindowsContainerSecurityContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsContainerSecurityContext {
        static instance: ::protobuf::rt::LazyV2<WindowsContainerSecurityContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsContainerSecurityContext::new)
    }
}

impl ::protobuf::Clear for WindowsContainerSecurityContext {
    fn clear(&mut self) {
        self.run_as_username.clear();
        self.credential_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsContainerSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsContainerSecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsContainerConfig {
    // message fields
    pub resources: ::protobuf::SingularPtrField<WindowsContainerResources>,
    pub security_context: ::protobuf::SingularPtrField<WindowsContainerSecurityContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsContainerConfig {
    fn default() -> &'a WindowsContainerConfig {
        <WindowsContainerConfig as ::protobuf::Message>::default_instance()
    }
}

impl WindowsContainerConfig {
    pub fn new() -> WindowsContainerConfig {
        ::std::default::Default::default()
    }

    // .runtime.v1.WindowsContainerResources resources = 1;


    pub fn get_resources(&self) -> &WindowsContainerResources {
        self.resources.as_ref().unwrap_or_else(|| <WindowsContainerResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: WindowsContainerResources) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut WindowsContainerResources {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> WindowsContainerResources {
        self.resources.take().unwrap_or_else(|| WindowsContainerResources::new())
    }

    // .runtime.v1.WindowsContainerSecurityContext security_context = 2;


    pub fn get_security_context(&self) -> &WindowsContainerSecurityContext {
        self.security_context.as_ref().unwrap_or_else(|| <WindowsContainerSecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_security_context(&mut self) {
        self.security_context.clear();
    }

    pub fn has_security_context(&self) -> bool {
        self.security_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_context(&mut self, v: WindowsContainerSecurityContext) {
        self.security_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_context(&mut self) -> &mut WindowsContainerSecurityContext {
        if self.security_context.is_none() {
            self.security_context.set_default();
        }
        self.security_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_context(&mut self) -> WindowsContainerSecurityContext {
        self.security_context.take().unwrap_or_else(|| WindowsContainerSecurityContext::new())
    }
}

impl ::protobuf::Message for WindowsContainerConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.security_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.security_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.security_context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsContainerConfig {
        WindowsContainerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsContainerResources>>(
                "resources",
                |m: &WindowsContainerConfig| { &m.resources },
                |m: &mut WindowsContainerConfig| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsContainerSecurityContext>>(
                "security_context",
                |m: &WindowsContainerConfig| { &m.security_context },
                |m: &mut WindowsContainerConfig| { &mut m.security_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsContainerConfig>(
                "WindowsContainerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsContainerConfig {
        static instance: ::protobuf::rt::LazyV2<WindowsContainerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsContainerConfig::new)
    }
}

impl ::protobuf::Clear for WindowsContainerConfig {
    fn clear(&mut self) {
        self.resources.clear();
        self.security_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsContainerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsContainerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsContainerResources {
    // message fields
    pub cpu_shares: i64,
    pub cpu_count: i64,
    pub cpu_maximum: i64,
    pub memory_limit_in_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsContainerResources {
    fn default() -> &'a WindowsContainerResources {
        <WindowsContainerResources as ::protobuf::Message>::default_instance()
    }
}

impl WindowsContainerResources {
    pub fn new() -> WindowsContainerResources {
        ::std::default::Default::default()
    }

    // int64 cpu_shares = 1;


    pub fn get_cpu_shares(&self) -> i64 {
        self.cpu_shares
    }
    pub fn clear_cpu_shares(&mut self) {
        self.cpu_shares = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_shares(&mut self, v: i64) {
        self.cpu_shares = v;
    }

    // int64 cpu_count = 2;


    pub fn get_cpu_count(&self) -> i64 {
        self.cpu_count
    }
    pub fn clear_cpu_count(&mut self) {
        self.cpu_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_count(&mut self, v: i64) {
        self.cpu_count = v;
    }

    // int64 cpu_maximum = 3;


    pub fn get_cpu_maximum(&self) -> i64 {
        self.cpu_maximum
    }
    pub fn clear_cpu_maximum(&mut self) {
        self.cpu_maximum = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_maximum(&mut self, v: i64) {
        self.cpu_maximum = v;
    }

    // int64 memory_limit_in_bytes = 4;


    pub fn get_memory_limit_in_bytes(&self) -> i64 {
        self.memory_limit_in_bytes
    }
    pub fn clear_memory_limit_in_bytes(&mut self) {
        self.memory_limit_in_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_limit_in_bytes(&mut self, v: i64) {
        self.memory_limit_in_bytes = v;
    }
}

impl ::protobuf::Message for WindowsContainerResources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_shares = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_maximum = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_limit_in_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpu_shares != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cpu_shares, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cpu_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpu_maximum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cpu_maximum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory_limit_in_bytes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.memory_limit_in_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cpu_shares != 0 {
            os.write_int64(1, self.cpu_shares)?;
        }
        if self.cpu_count != 0 {
            os.write_int64(2, self.cpu_count)?;
        }
        if self.cpu_maximum != 0 {
            os.write_int64(3, self.cpu_maximum)?;
        }
        if self.memory_limit_in_bytes != 0 {
            os.write_int64(4, self.memory_limit_in_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsContainerResources {
        WindowsContainerResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_shares",
                |m: &WindowsContainerResources| { &m.cpu_shares },
                |m: &mut WindowsContainerResources| { &mut m.cpu_shares },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_count",
                |m: &WindowsContainerResources| { &m.cpu_count },
                |m: &mut WindowsContainerResources| { &mut m.cpu_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cpu_maximum",
                |m: &WindowsContainerResources| { &m.cpu_maximum },
                |m: &mut WindowsContainerResources| { &mut m.cpu_maximum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "memory_limit_in_bytes",
                |m: &WindowsContainerResources| { &m.memory_limit_in_bytes },
                |m: &mut WindowsContainerResources| { &mut m.memory_limit_in_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsContainerResources>(
                "WindowsContainerResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsContainerResources {
        static instance: ::protobuf::rt::LazyV2<WindowsContainerResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsContainerResources::new)
    }
}

impl ::protobuf::Clear for WindowsContainerResources {
    fn clear(&mut self) {
        self.cpu_shares = 0;
        self.cpu_count = 0;
        self.cpu_maximum = 0;
        self.memory_limit_in_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsContainerResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsContainerResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerMetadata {
    // message fields
    pub name: ::std::string::String,
    pub attempt: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerMetadata {
    fn default() -> &'a ContainerMetadata {
        <ContainerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ContainerMetadata {
    pub fn new() -> ContainerMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 attempt = 2;


    pub fn get_attempt(&self) -> u32 {
        self.attempt
    }
    pub fn clear_attempt(&mut self) {
        self.attempt = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt(&mut self, v: u32) {
        self.attempt = v;
    }
}

impl ::protobuf::Message for ContainerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.attempt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.attempt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.attempt != 0 {
            os.write_uint32(2, self.attempt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerMetadata {
        ContainerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ContainerMetadata| { &m.name },
                |m: &mut ContainerMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attempt",
                |m: &ContainerMetadata| { &m.attempt },
                |m: &mut ContainerMetadata| { &mut m.attempt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerMetadata>(
                "ContainerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerMetadata {
        static instance: ::protobuf::rt::LazyV2<ContainerMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerMetadata::new)
    }
}

impl ::protobuf::Clear for ContainerMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.attempt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub container_path: ::std::string::String,
    pub host_path: ::std::string::String,
    pub permissions: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string container_path = 1;


    pub fn get_container_path(&self) -> &str {
        &self.container_path
    }
    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path(&mut self) -> &mut ::std::string::String {
        &mut self.container_path
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_path, ::std::string::String::new())
    }

    // string host_path = 2;


    pub fn get_host_path(&self) -> &str {
        &self.host_path
    }
    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: ::std::string::String) {
        self.host_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path(&mut self) -> &mut ::std::string::String {
        &mut self.host_path
    }

    // Take field
    pub fn take_host_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_path, ::std::string::String::new())
    }

    // string permissions = 3;


    pub fn get_permissions(&self) -> &str {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::std::string::String) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissions(&mut self) -> &mut ::std::string::String {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissions, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_path);
        }
        if !self.host_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host_path);
        }
        if !self.permissions.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.permissions);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_path.is_empty() {
            os.write_string(1, &self.container_path)?;
        }
        if !self.host_path.is_empty() {
            os.write_string(2, &self.host_path)?;
        }
        if !self.permissions.is_empty() {
            os.write_string(3, &self.permissions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_path",
                |m: &Device| { &m.container_path },
                |m: &mut Device| { &mut m.container_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_path",
                |m: &Device| { &m.host_path },
                |m: &mut Device| { &mut m.host_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissions",
                |m: &Device| { &m.permissions },
                |m: &mut Device| { &mut m.permissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Device>(
                "Device",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Device {
        static instance: ::protobuf::rt::LazyV2<Device> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Device::new)
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.container_path.clear();
        self.host_path.clear();
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerConfig {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub working_dir: ::std::string::String,
    pub envs: ::protobuf::RepeatedField<KeyValue>,
    pub mounts: ::protobuf::RepeatedField<Mount>,
    pub devices: ::protobuf::RepeatedField<Device>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub log_path: ::std::string::String,
    pub stdin: bool,
    pub stdin_once: bool,
    pub tty: bool,
    pub linux: ::protobuf::SingularPtrField<LinuxContainerConfig>,
    pub windows: ::protobuf::SingularPtrField<WindowsContainerConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerConfig {
    fn default() -> &'a ContainerConfig {
        <ContainerConfig as ::protobuf::Message>::default_instance()
    }
}

impl ContainerConfig {
    pub fn new() -> ContainerConfig {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerMetadata metadata = 1;


    pub fn get_metadata(&self) -> &ContainerMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ContainerMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ContainerMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ContainerMetadata {
        self.metadata.take().unwrap_or_else(|| ContainerMetadata::new())
    }

    // .runtime.v1.ImageSpec image = 2;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }

    // repeated string command = 3;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 4;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // string working_dir = 5;


    pub fn get_working_dir(&self) -> &str {
        &self.working_dir
    }
    pub fn clear_working_dir(&mut self) {
        self.working_dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_working_dir(&mut self, v: ::std::string::String) {
        self.working_dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_dir(&mut self) -> &mut ::std::string::String {
        &mut self.working_dir
    }

    // Take field
    pub fn take_working_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.working_dir, ::std::string::String::new())
    }

    // repeated .runtime.v1.KeyValue envs = 6;


    pub fn get_envs(&self) -> &[KeyValue] {
        &self.envs
    }
    pub fn clear_envs(&mut self) {
        self.envs.clear();
    }

    // Param is passed by value, moved
    pub fn set_envs(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.envs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envs(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.envs
    }

    // Take field
    pub fn take_envs(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.envs, ::protobuf::RepeatedField::new())
    }

    // repeated .runtime.v1.Mount mounts = 7;


    pub fn get_mounts(&self) -> &[Mount] {
        &self.mounts
    }
    pub fn clear_mounts(&mut self) {
        self.mounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_mounts(&mut self, v: ::protobuf::RepeatedField<Mount>) {
        self.mounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mounts(&mut self) -> &mut ::protobuf::RepeatedField<Mount> {
        &mut self.mounts
    }

    // Take field
    pub fn take_mounts(&mut self) -> ::protobuf::RepeatedField<Mount> {
        ::std::mem::replace(&mut self.mounts, ::protobuf::RepeatedField::new())
    }

    // repeated .runtime.v1.Device devices = 8;


    pub fn get_devices(&self) -> &[Device] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<Device> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }

    // repeated .runtime.v1.ContainerConfig.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.ContainerConfig.AnnotationsEntry annotations = 10;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // string log_path = 11;


    pub fn get_log_path(&self) -> &str {
        &self.log_path
    }
    pub fn clear_log_path(&mut self) {
        self.log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_path(&mut self, v: ::std::string::String) {
        self.log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.log_path
    }

    // Take field
    pub fn take_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_path, ::std::string::String::new())
    }

    // bool stdin = 12;


    pub fn get_stdin(&self) -> bool {
        self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = false;
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = v;
    }

    // bool stdin_once = 13;


    pub fn get_stdin_once(&self) -> bool {
        self.stdin_once
    }
    pub fn clear_stdin_once(&mut self) {
        self.stdin_once = false;
    }

    // Param is passed by value, moved
    pub fn set_stdin_once(&mut self, v: bool) {
        self.stdin_once = v;
    }

    // bool tty = 14;


    pub fn get_tty(&self) -> bool {
        self.tty
    }
    pub fn clear_tty(&mut self) {
        self.tty = false;
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = v;
    }

    // .runtime.v1.LinuxContainerConfig linux = 15;


    pub fn get_linux(&self) -> &LinuxContainerConfig {
        self.linux.as_ref().unwrap_or_else(|| <LinuxContainerConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux(&mut self) {
        self.linux.clear();
    }

    pub fn has_linux(&self) -> bool {
        self.linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux(&mut self, v: LinuxContainerConfig) {
        self.linux = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux(&mut self) -> &mut LinuxContainerConfig {
        if self.linux.is_none() {
            self.linux.set_default();
        }
        self.linux.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux(&mut self) -> LinuxContainerConfig {
        self.linux.take().unwrap_or_else(|| LinuxContainerConfig::new())
    }

    // .runtime.v1.WindowsContainerConfig windows = 16;


    pub fn get_windows(&self) -> &WindowsContainerConfig {
        self.windows.as_ref().unwrap_or_else(|| <WindowsContainerConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows(&mut self) {
        self.windows.clear();
    }

    pub fn has_windows(&self) -> bool {
        self.windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows(&mut self, v: WindowsContainerConfig) {
        self.windows = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows(&mut self) -> &mut WindowsContainerConfig {
        if self.windows.is_none() {
            self.windows.set_default();
        }
        self.windows.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows(&mut self) -> WindowsContainerConfig {
        self.windows.take().unwrap_or_else(|| WindowsContainerConfig::new())
    }
}

impl ::protobuf::Message for ContainerConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linux {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.working_dir)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.envs)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mounts)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_path)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin_once = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.working_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.working_dir);
        }
        for value in &self.envs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.mounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.annotations);
        if !self.log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.log_path);
        }
        if self.stdin != false {
            my_size += 2;
        }
        if self.stdin_once != false {
            my_size += 2;
        }
        if self.tty != false {
            my_size += 2;
        }
        if let Some(ref v) = self.linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if !self.working_dir.is_empty() {
            os.write_string(5, &self.working_dir)?;
        }
        for v in &self.envs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.mounts {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.devices {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.annotations, os)?;
        if !self.log_path.is_empty() {
            os.write_string(11, &self.log_path)?;
        }
        if self.stdin != false {
            os.write_bool(12, self.stdin)?;
        }
        if self.stdin_once != false {
            os.write_bool(13, self.stdin_once)?;
        }
        if self.tty != false {
            os.write_bool(14, self.tty)?;
        }
        if let Some(ref v) = self.linux.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerConfig {
        ContainerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "metadata",
                |m: &ContainerConfig| { &m.metadata },
                |m: &mut ContainerConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &ContainerConfig| { &m.image },
                |m: &mut ContainerConfig| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &ContainerConfig| { &m.command },
                |m: &mut ContainerConfig| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &ContainerConfig| { &m.args },
                |m: &mut ContainerConfig| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "working_dir",
                |m: &ContainerConfig| { &m.working_dir },
                |m: &mut ContainerConfig| { &mut m.working_dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                "envs",
                |m: &ContainerConfig| { &m.envs },
                |m: &mut ContainerConfig| { &mut m.envs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mount>>(
                "mounts",
                |m: &ContainerConfig| { &m.mounts },
                |m: &mut ContainerConfig| { &mut m.mounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                "devices",
                |m: &ContainerConfig| { &m.devices },
                |m: &mut ContainerConfig| { &mut m.devices },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &ContainerConfig| { &m.labels },
                |m: &mut ContainerConfig| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ContainerConfig| { &m.annotations },
                |m: &mut ContainerConfig| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "log_path",
                |m: &ContainerConfig| { &m.log_path },
                |m: &mut ContainerConfig| { &mut m.log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &ContainerConfig| { &m.stdin },
                |m: &mut ContainerConfig| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin_once",
                |m: &ContainerConfig| { &m.stdin_once },
                |m: &mut ContainerConfig| { &mut m.stdin_once },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &ContainerConfig| { &m.tty },
                |m: &mut ContainerConfig| { &mut m.tty },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxContainerConfig>>(
                "linux",
                |m: &ContainerConfig| { &m.linux },
                |m: &mut ContainerConfig| { &mut m.linux },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsContainerConfig>>(
                "windows",
                |m: &ContainerConfig| { &m.windows },
                |m: &mut ContainerConfig| { &mut m.windows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerConfig>(
                "ContainerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerConfig {
        static instance: ::protobuf::rt::LazyV2<ContainerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerConfig::new)
    }
}

impl ::protobuf::Clear for ContainerConfig {
    fn clear(&mut self) {
        self.metadata.clear();
        self.image.clear();
        self.command.clear();
        self.args.clear();
        self.working_dir.clear();
        self.envs.clear();
        self.mounts.clear();
        self.devices.clear();
        self.labels.clear();
        self.annotations.clear();
        self.log_path.clear();
        self.stdin = false;
        self.stdin_once = false;
        self.tty = false;
        self.linux.clear();
        self.windows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContainerRequest {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    pub config: ::protobuf::SingularPtrField<ContainerConfig>,
    pub sandbox_config: ::protobuf::SingularPtrField<PodSandboxConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContainerRequest {
    fn default() -> &'a CreateContainerRequest {
        <CreateContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerRequest {
    pub fn new() -> CreateContainerRequest {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // .runtime.v1.ContainerConfig config = 2;


    pub fn get_config(&self) -> &ContainerConfig {
        self.config.as_ref().unwrap_or_else(|| <ContainerConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ContainerConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ContainerConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ContainerConfig {
        self.config.take().unwrap_or_else(|| ContainerConfig::new())
    }

    // .runtime.v1.PodSandboxConfig sandbox_config = 3;


    pub fn get_sandbox_config(&self) -> &PodSandboxConfig {
        self.sandbox_config.as_ref().unwrap_or_else(|| <PodSandboxConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sandbox_config(&mut self) {
        self.sandbox_config.clear();
    }

    pub fn has_sandbox_config(&self) -> bool {
        self.sandbox_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sandbox_config(&mut self, v: PodSandboxConfig) {
        self.sandbox_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_config(&mut self) -> &mut PodSandboxConfig {
        if self.sandbox_config.is_none() {
            self.sandbox_config.set_default();
        }
        self.sandbox_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_sandbox_config(&mut self) -> PodSandboxConfig {
        self.sandbox_config.take().unwrap_or_else(|| PodSandboxConfig::new())
    }
}

impl ::protobuf::Message for CreateContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sandbox_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sandbox_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sandbox_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sandbox_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContainerRequest {
        CreateContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &CreateContainerRequest| { &m.pod_sandbox_id },
                |m: &mut CreateContainerRequest| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerConfig>>(
                "config",
                |m: &CreateContainerRequest| { &m.config },
                |m: &mut CreateContainerRequest| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxConfig>>(
                "sandbox_config",
                |m: &CreateContainerRequest| { &m.sandbox_config },
                |m: &mut CreateContainerRequest| { &mut m.sandbox_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContainerRequest>(
                "CreateContainerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateContainerRequest {
        static instance: ::protobuf::rt::LazyV2<CreateContainerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateContainerRequest::new)
    }
}

impl ::protobuf::Clear for CreateContainerRequest {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.config.clear();
        self.sandbox_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContainerResponse {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContainerResponse {
    fn default() -> &'a CreateContainerResponse {
        <CreateContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateContainerResponse {
    pub fn new() -> CreateContainerResponse {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateContainerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContainerResponse {
        CreateContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &CreateContainerResponse| { &m.container_id },
                |m: &mut CreateContainerResponse| { &mut m.container_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContainerResponse>(
                "CreateContainerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateContainerResponse {
        static instance: ::protobuf::rt::LazyV2<CreateContainerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateContainerResponse::new)
    }
}

impl ::protobuf::Clear for CreateContainerResponse {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartContainerRequest {
    fn default() -> &'a StartContainerRequest {
        <StartContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartContainerRequest {
    pub fn new() -> StartContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StartContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartContainerRequest {
        StartContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &StartContainerRequest| { &m.container_id },
                |m: &mut StartContainerRequest| { &mut m.container_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartContainerRequest>(
                "StartContainerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartContainerRequest {
        static instance: ::protobuf::rt::LazyV2<StartContainerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartContainerRequest::new)
    }
}

impl ::protobuf::Clear for StartContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartContainerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartContainerResponse {
    fn default() -> &'a StartContainerResponse {
        <StartContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartContainerResponse {
    pub fn new() -> StartContainerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartContainerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartContainerResponse {
        StartContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartContainerResponse>(
                "StartContainerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartContainerResponse {
        static instance: ::protobuf::rt::LazyV2<StartContainerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartContainerResponse::new)
    }
}

impl ::protobuf::Clear for StartContainerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub timeout: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopContainerRequest {
    fn default() -> &'a StopContainerRequest {
        <StopContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopContainerRequest {
    pub fn new() -> StopContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // int64 timeout = 2;


    pub fn get_timeout(&self) -> i64 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: i64) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for StopContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.timeout != 0 {
            os.write_int64(2, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopContainerRequest {
        StopContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &StopContainerRequest| { &m.container_id },
                |m: &mut StopContainerRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeout",
                |m: &StopContainerRequest| { &m.timeout },
                |m: &mut StopContainerRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopContainerRequest>(
                "StopContainerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopContainerRequest {
        static instance: ::protobuf::rt::LazyV2<StopContainerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopContainerRequest::new)
    }
}

impl ::protobuf::Clear for StopContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopContainerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopContainerResponse {
    fn default() -> &'a StopContainerResponse {
        <StopContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopContainerResponse {
    pub fn new() -> StopContainerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopContainerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopContainerResponse {
        StopContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopContainerResponse>(
                "StopContainerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopContainerResponse {
        static instance: ::protobuf::rt::LazyV2<StopContainerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopContainerResponse::new)
    }
}

impl ::protobuf::Clear for StopContainerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerRequest {
    fn default() -> &'a RemoveContainerRequest {
        <RemoveContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerRequest {
    pub fn new() -> RemoveContainerRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveContainerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerRequest {
        RemoveContainerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &RemoveContainerRequest| { &m.container_id },
                |m: &mut RemoveContainerRequest| { &mut m.container_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveContainerRequest>(
                "RemoveContainerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveContainerRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveContainerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveContainerRequest::new)
    }
}

impl ::protobuf::Clear for RemoveContainerRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveContainerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveContainerResponse {
    fn default() -> &'a RemoveContainerResponse {
        <RemoveContainerResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemoveContainerResponse {
    pub fn new() -> RemoveContainerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveContainerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveContainerResponse {
        RemoveContainerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveContainerResponse>(
                "RemoveContainerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveContainerResponse {
        static instance: ::protobuf::rt::LazyV2<RemoveContainerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveContainerResponse::new)
    }
}

impl ::protobuf::Clear for RemoveContainerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveContainerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveContainerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateValue {
    // message fields
    pub state: ContainerState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStateValue {
    fn default() -> &'a ContainerStateValue {
        <ContainerStateValue as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateValue {
    pub fn new() -> ContainerStateValue {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerState state = 1;


    pub fn get_state(&self) -> ContainerState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = ContainerState::CONTAINER_CREATED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = v;
    }
}

impl ::protobuf::Message for ContainerStateValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != ContainerState::CONTAINER_CREATED {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != ContainerState::CONTAINER_CREATED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStateValue {
        ContainerStateValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContainerState>>(
                "state",
                |m: &ContainerStateValue| { &m.state },
                |m: &mut ContainerStateValue| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStateValue>(
                "ContainerStateValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStateValue {
        static instance: ::protobuf::rt::LazyV2<ContainerStateValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStateValue::new)
    }
}

impl ::protobuf::Clear for ContainerStateValue {
    fn clear(&mut self) {
        self.state = ContainerState::CONTAINER_CREATED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerFilter {
    // message fields
    pub id: ::std::string::String,
    pub state: ::protobuf::SingularPtrField<ContainerStateValue>,
    pub pod_sandbox_id: ::std::string::String,
    pub label_selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerFilter {
    fn default() -> &'a ContainerFilter {
        <ContainerFilter as ::protobuf::Message>::default_instance()
    }
}

impl ContainerFilter {
    pub fn new() -> ContainerFilter {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.ContainerStateValue state = 2;


    pub fn get_state(&self) -> &ContainerStateValue {
        self.state.as_ref().unwrap_or_else(|| <ContainerStateValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerStateValue) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ContainerStateValue {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ContainerStateValue {
        self.state.take().unwrap_or_else(|| ContainerStateValue::new())
    }

    // string pod_sandbox_id = 3;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // repeated .runtime.v1.ContainerFilter.LabelSelectorEntry label_selector = 4;


    pub fn get_label_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.label_selector
    }
    pub fn clear_label_selector(&mut self) {
        self.label_selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.label_selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.label_selector
    }

    // Take field
    pub fn take_label_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.label_selector, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ContainerFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.label_selector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.pod_sandbox_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.label_selector);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(3, &self.pod_sandbox_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.label_selector, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerFilter {
        ContainerFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ContainerFilter| { &m.id },
                |m: &mut ContainerFilter| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateValue>>(
                "state",
                |m: &ContainerFilter| { &m.state },
                |m: &mut ContainerFilter| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &ContainerFilter| { &m.pod_sandbox_id },
                |m: &mut ContainerFilter| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "label_selector",
                |m: &ContainerFilter| { &m.label_selector },
                |m: &mut ContainerFilter| { &mut m.label_selector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerFilter>(
                "ContainerFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerFilter {
        static instance: ::protobuf::rt::LazyV2<ContainerFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerFilter::new)
    }
}

impl ::protobuf::Clear for ContainerFilter {
    fn clear(&mut self) {
        self.id.clear();
        self.state.clear();
        self.pod_sandbox_id.clear();
        self.label_selector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListContainersRequest {
    // message fields
    pub filter: ::protobuf::SingularPtrField<ContainerFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListContainersRequest {
    fn default() -> &'a ListContainersRequest {
        <ListContainersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListContainersRequest {
    pub fn new() -> ListContainersRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerFilter filter = 1;


    pub fn get_filter(&self) -> &ContainerFilter {
        self.filter.as_ref().unwrap_or_else(|| <ContainerFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ContainerFilter) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ContainerFilter {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ContainerFilter {
        self.filter.take().unwrap_or_else(|| ContainerFilter::new())
    }
}

impl ::protobuf::Message for ListContainersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListContainersRequest {
        ListContainersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerFilter>>(
                "filter",
                |m: &ListContainersRequest| { &m.filter },
                |m: &mut ListContainersRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListContainersRequest>(
                "ListContainersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListContainersRequest {
        static instance: ::protobuf::rt::LazyV2<ListContainersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListContainersRequest::new)
    }
}

impl ::protobuf::Clear for ListContainersRequest {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListContainersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListContainersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Container {
    // message fields
    pub id: ::std::string::String,
    pub pod_sandbox_id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    pub image_ref: ::std::string::String,
    pub state: ContainerState,
    pub created_at: i64,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Container {
    fn default() -> &'a Container {
        <Container as ::protobuf::Message>::default_instance()
    }
}

impl Container {
    pub fn new() -> Container {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string pod_sandbox_id = 2;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // .runtime.v1.ContainerMetadata metadata = 3;


    pub fn get_metadata(&self) -> &ContainerMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ContainerMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ContainerMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ContainerMetadata {
        self.metadata.take().unwrap_or_else(|| ContainerMetadata::new())
    }

    // .runtime.v1.ImageSpec image = 4;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }

    // string image_ref = 5;


    pub fn get_image_ref(&self) -> &str {
        &self.image_ref
    }
    pub fn clear_image_ref(&mut self) {
        self.image_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_ref(&mut self, v: ::std::string::String) {
        self.image_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_ref(&mut self) -> &mut ::std::string::String {
        &mut self.image_ref
    }

    // Take field
    pub fn take_image_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_ref, ::std::string::String::new())
    }

    // .runtime.v1.ContainerState state = 6;


    pub fn get_state(&self) -> ContainerState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = ContainerState::CONTAINER_CREATED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = v;
    }

    // int64 created_at = 7;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // repeated .runtime.v1.Container.LabelsEntry labels = 8;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.Container.AnnotationsEntry annotations = 9;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Container {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_ref)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_at = tmp;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pod_sandbox_id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.image_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.image_ref);
        }
        if self.state != ContainerState::CONTAINER_CREATED {
            my_size += ::protobuf::rt::enum_size(6, self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(7, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.annotations);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(2, &self.pod_sandbox_id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.image_ref.is_empty() {
            os.write_string(5, &self.image_ref)?;
        }
        if self.state != ContainerState::CONTAINER_CREATED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.created_at != 0 {
            os.write_int64(7, self.created_at)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.annotations, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Container {
        Container::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Container| { &m.id },
                |m: &mut Container| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &Container| { &m.pod_sandbox_id },
                |m: &mut Container| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "metadata",
                |m: &Container| { &m.metadata },
                |m: &mut Container| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &Container| { &m.image },
                |m: &mut Container| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_ref",
                |m: &Container| { &m.image_ref },
                |m: &mut Container| { &mut m.image_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContainerState>>(
                "state",
                |m: &Container| { &m.state },
                |m: &mut Container| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "created_at",
                |m: &Container| { &m.created_at },
                |m: &mut Container| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Container| { &m.labels },
                |m: &mut Container| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &Container| { &m.annotations },
                |m: &mut Container| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Container>(
                "Container",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Container {
        static instance: ::protobuf::rt::LazyV2<Container> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Container::new)
    }
}

impl ::protobuf::Clear for Container {
    fn clear(&mut self) {
        self.id.clear();
        self.pod_sandbox_id.clear();
        self.metadata.clear();
        self.image.clear();
        self.image_ref.clear();
        self.state = ContainerState::CONTAINER_CREATED;
        self.created_at = 0;
        self.labels.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Container {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListContainersResponse {
    // message fields
    pub containers: ::protobuf::RepeatedField<Container>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListContainersResponse {
    fn default() -> &'a ListContainersResponse {
        <ListContainersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListContainersResponse {
    pub fn new() -> ListContainersResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.Container containers = 1;


    pub fn get_containers(&self) -> &[Container] {
        &self.containers
    }
    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.containers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListContainersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.containers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.containers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListContainersResponse {
        ListContainersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                "containers",
                |m: &ListContainersResponse| { &m.containers },
                |m: &mut ListContainersResponse| { &mut m.containers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListContainersResponse>(
                "ListContainersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListContainersResponse {
        static instance: ::protobuf::rt::LazyV2<ListContainersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListContainersResponse::new)
    }
}

impl ::protobuf::Clear for ListContainersResponse {
    fn clear(&mut self) {
        self.containers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListContainersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListContainersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatusRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub verbose: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatusRequest {
    fn default() -> &'a ContainerStatusRequest {
        <ContainerStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatusRequest {
    pub fn new() -> ContainerStatusRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // bool verbose = 2;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }
}

impl ::protobuf::Message for ContainerStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.verbose != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.verbose != false {
            os.write_bool(2, self.verbose)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatusRequest {
        ContainerStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &ContainerStatusRequest| { &m.container_id },
                |m: &mut ContainerStatusRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verbose",
                |m: &ContainerStatusRequest| { &m.verbose },
                |m: &mut ContainerStatusRequest| { &mut m.verbose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatusRequest>(
                "ContainerStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatusRequest {
        static instance: ::protobuf::rt::LazyV2<ContainerStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatusRequest::new)
    }
}

impl ::protobuf::Clear for ContainerStatusRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.verbose = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatus {
    // message fields
    pub id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub state: ContainerState,
    pub created_at: i64,
    pub started_at: i64,
    pub finished_at: i64,
    pub exit_code: i32,
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    pub image_ref: ::std::string::String,
    pub reason: ::std::string::String,
    pub message: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub mounts: ::protobuf::RepeatedField<Mount>,
    pub log_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatus {
    fn default() -> &'a ContainerStatus {
        <ContainerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.ContainerMetadata metadata = 2;


    pub fn get_metadata(&self) -> &ContainerMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ContainerMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ContainerMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ContainerMetadata {
        self.metadata.take().unwrap_or_else(|| ContainerMetadata::new())
    }

    // .runtime.v1.ContainerState state = 3;


    pub fn get_state(&self) -> ContainerState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = ContainerState::CONTAINER_CREATED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = v;
    }

    // int64 created_at = 4;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // int64 started_at = 5;


    pub fn get_started_at(&self) -> i64 {
        self.started_at
    }
    pub fn clear_started_at(&mut self) {
        self.started_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_started_at(&mut self, v: i64) {
        self.started_at = v;
    }

    // int64 finished_at = 6;


    pub fn get_finished_at(&self) -> i64 {
        self.finished_at
    }
    pub fn clear_finished_at(&mut self) {
        self.finished_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_finished_at(&mut self, v: i64) {
        self.finished_at = v;
    }

    // int32 exit_code = 7;


    pub fn get_exit_code(&self) -> i32 {
        self.exit_code
    }
    pub fn clear_exit_code(&mut self) {
        self.exit_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_code(&mut self, v: i32) {
        self.exit_code = v;
    }

    // .runtime.v1.ImageSpec image = 8;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }

    // string image_ref = 9;


    pub fn get_image_ref(&self) -> &str {
        &self.image_ref
    }
    pub fn clear_image_ref(&mut self) {
        self.image_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_ref(&mut self, v: ::std::string::String) {
        self.image_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_ref(&mut self) -> &mut ::std::string::String {
        &mut self.image_ref
    }

    // Take field
    pub fn take_image_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_ref, ::std::string::String::new())
    }

    // string reason = 10;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }

    // string message = 11;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // repeated .runtime.v1.ContainerStatus.LabelsEntry labels = 12;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.ContainerStatus.AnnotationsEntry annotations = 13;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.Mount mounts = 14;


    pub fn get_mounts(&self) -> &[Mount] {
        &self.mounts
    }
    pub fn clear_mounts(&mut self) {
        self.mounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_mounts(&mut self, v: ::protobuf::RepeatedField<Mount>) {
        self.mounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mounts(&mut self) -> &mut ::protobuf::RepeatedField<Mount> {
        &mut self.mounts
    }

    // Take field
    pub fn take_mounts(&mut self) -> ::protobuf::RepeatedField<Mount> {
        ::std::mem::replace(&mut self.mounts, ::protobuf::RepeatedField::new())
    }

    // string log_path = 15;


    pub fn get_log_path(&self) -> &str {
        &self.log_path
    }
    pub fn clear_log_path(&mut self) {
        self.log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_path(&mut self, v: ::std::string::String) {
        self.log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.log_path
    }

    // Take field
    pub fn take_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_at = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.started_at = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.finished_at = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exit_code = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_ref)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mounts)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.state != ContainerState::CONTAINER_CREATED {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.started_at != 0 {
            my_size += ::protobuf::rt::value_size(5, self.started_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.finished_at != 0 {
            my_size += ::protobuf::rt::value_size(6, self.finished_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exit_code != 0 {
            my_size += ::protobuf::rt::value_size(7, self.exit_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.image_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.image_ref);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.reason);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.message);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.annotations);
        for value in &self.mounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.log_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.state != ContainerState::CONTAINER_CREATED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.created_at != 0 {
            os.write_int64(4, self.created_at)?;
        }
        if self.started_at != 0 {
            os.write_int64(5, self.started_at)?;
        }
        if self.finished_at != 0 {
            os.write_int64(6, self.finished_at)?;
        }
        if self.exit_code != 0 {
            os.write_int32(7, self.exit_code)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.image_ref.is_empty() {
            os.write_string(9, &self.image_ref)?;
        }
        if !self.reason.is_empty() {
            os.write_string(10, &self.reason)?;
        }
        if !self.message.is_empty() {
            os.write_string(11, &self.message)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.annotations, os)?;
        for v in &self.mounts {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.log_path.is_empty() {
            os.write_string(15, &self.log_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ContainerStatus| { &m.id },
                |m: &mut ContainerStatus| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "metadata",
                |m: &ContainerStatus| { &m.metadata },
                |m: &mut ContainerStatus| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContainerState>>(
                "state",
                |m: &ContainerStatus| { &m.state },
                |m: &mut ContainerStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "created_at",
                |m: &ContainerStatus| { &m.created_at },
                |m: &mut ContainerStatus| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "started_at",
                |m: &ContainerStatus| { &m.started_at },
                |m: &mut ContainerStatus| { &mut m.started_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "finished_at",
                |m: &ContainerStatus| { &m.finished_at },
                |m: &mut ContainerStatus| { &mut m.finished_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "exit_code",
                |m: &ContainerStatus| { &m.exit_code },
                |m: &mut ContainerStatus| { &mut m.exit_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &ContainerStatus| { &m.image },
                |m: &mut ContainerStatus| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_ref",
                |m: &ContainerStatus| { &m.image_ref },
                |m: &mut ContainerStatus| { &mut m.image_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ContainerStatus| { &m.reason },
                |m: &mut ContainerStatus| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ContainerStatus| { &m.message },
                |m: &mut ContainerStatus| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &ContainerStatus| { &m.labels },
                |m: &mut ContainerStatus| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ContainerStatus| { &m.annotations },
                |m: &mut ContainerStatus| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mount>>(
                "mounts",
                |m: &ContainerStatus| { &m.mounts },
                |m: &mut ContainerStatus| { &mut m.mounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "log_path",
                |m: &ContainerStatus| { &m.log_path },
                |m: &mut ContainerStatus| { &mut m.log_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatus>(
                "ContainerStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatus {
        static instance: ::protobuf::rt::LazyV2<ContainerStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatus::new)
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.id.clear();
        self.metadata.clear();
        self.state = ContainerState::CONTAINER_CREATED;
        self.created_at = 0;
        self.started_at = 0;
        self.finished_at = 0;
        self.exit_code = 0;
        self.image.clear();
        self.image_ref.clear();
        self.reason.clear();
        self.message.clear();
        self.labels.clear();
        self.annotations.clear();
        self.mounts.clear();
        self.log_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<ContainerStatus>,
    pub info: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatusResponse {
    fn default() -> &'a ContainerStatusResponse {
        <ContainerStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatusResponse {
    pub fn new() -> ContainerStatusResponse {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerStatus status = 1;


    pub fn get_status(&self) -> &ContainerStatus {
        self.status.as_ref().unwrap_or_else(|| <ContainerStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ContainerStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ContainerStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ContainerStatus {
        self.status.take().unwrap_or_else(|| ContainerStatus::new())
    }

    // repeated .runtime.v1.ContainerStatusResponse.InfoEntry info = 2;


    pub fn get_info(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.info, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ContainerStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatusResponse {
        ContainerStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                "status",
                |m: &ContainerStatusResponse| { &m.status },
                |m: &mut ContainerStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &ContainerStatusResponse| { &m.info },
                |m: &mut ContainerStatusResponse| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatusResponse>(
                "ContainerStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatusResponse {
        static instance: ::protobuf::rt::LazyV2<ContainerStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatusResponse::new)
    }
}

impl ::protobuf::Clear for ContainerStatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContainerResourcesRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub linux: ::protobuf::SingularPtrField<LinuxContainerResources>,
    pub windows: ::protobuf::SingularPtrField<WindowsContainerResources>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContainerResourcesRequest {
    fn default() -> &'a UpdateContainerResourcesRequest {
        <UpdateContainerResourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContainerResourcesRequest {
    pub fn new() -> UpdateContainerResourcesRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // .runtime.v1.LinuxContainerResources linux = 2;


    pub fn get_linux(&self) -> &LinuxContainerResources {
        self.linux.as_ref().unwrap_or_else(|| <LinuxContainerResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linux(&mut self) {
        self.linux.clear();
    }

    pub fn has_linux(&self) -> bool {
        self.linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linux(&mut self, v: LinuxContainerResources) {
        self.linux = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linux(&mut self) -> &mut LinuxContainerResources {
        if self.linux.is_none() {
            self.linux.set_default();
        }
        self.linux.as_mut().unwrap()
    }

    // Take field
    pub fn take_linux(&mut self) -> LinuxContainerResources {
        self.linux.take().unwrap_or_else(|| LinuxContainerResources::new())
    }

    // .runtime.v1.WindowsContainerResources windows = 3;


    pub fn get_windows(&self) -> &WindowsContainerResources {
        self.windows.as_ref().unwrap_or_else(|| <WindowsContainerResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windows(&mut self) {
        self.windows.clear();
    }

    pub fn has_windows(&self) -> bool {
        self.windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windows(&mut self, v: WindowsContainerResources) {
        self.windows = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windows(&mut self) -> &mut WindowsContainerResources {
        if self.windows.is_none() {
            self.windows.set_default();
        }
        self.windows.as_mut().unwrap()
    }

    // Take field
    pub fn take_windows(&mut self) -> WindowsContainerResources {
        self.windows.take().unwrap_or_else(|| WindowsContainerResources::new())
    }

    // repeated .runtime.v1.UpdateContainerResourcesRequest.AnnotationsEntry annotations = 4;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for UpdateContainerResourcesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.linux {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linux)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windows)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if let Some(ref v) = self.linux.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windows.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.annotations);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if let Some(ref v) = self.linux.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windows.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.annotations, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContainerResourcesRequest {
        UpdateContainerResourcesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &UpdateContainerResourcesRequest| { &m.container_id },
                |m: &mut UpdateContainerResourcesRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinuxContainerResources>>(
                "linux",
                |m: &UpdateContainerResourcesRequest| { &m.linux },
                |m: &mut UpdateContainerResourcesRequest| { &mut m.linux },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsContainerResources>>(
                "windows",
                |m: &UpdateContainerResourcesRequest| { &m.windows },
                |m: &mut UpdateContainerResourcesRequest| { &mut m.windows },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &UpdateContainerResourcesRequest| { &m.annotations },
                |m: &mut UpdateContainerResourcesRequest| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateContainerResourcesRequest>(
                "UpdateContainerResourcesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateContainerResourcesRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateContainerResourcesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateContainerResourcesRequest::new)
    }
}

impl ::protobuf::Clear for UpdateContainerResourcesRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.linux.clear();
        self.windows.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContainerResourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContainerResourcesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateContainerResourcesResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateContainerResourcesResponse {
    fn default() -> &'a UpdateContainerResourcesResponse {
        <UpdateContainerResourcesResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateContainerResourcesResponse {
    pub fn new() -> UpdateContainerResourcesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateContainerResourcesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateContainerResourcesResponse {
        UpdateContainerResourcesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateContainerResourcesResponse>(
                "UpdateContainerResourcesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateContainerResourcesResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateContainerResourcesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateContainerResourcesResponse::new)
    }
}

impl ::protobuf::Clear for UpdateContainerResourcesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateContainerResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateContainerResourcesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecSyncRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub cmd: ::protobuf::RepeatedField<::std::string::String>,
    pub timeout: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecSyncRequest {
    fn default() -> &'a ExecSyncRequest {
        <ExecSyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecSyncRequest {
    pub fn new() -> ExecSyncRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // repeated string cmd = 2;


    pub fn get_cmd(&self) -> &[::std::string::String] {
        &self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmd(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmd
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmd, ::protobuf::RepeatedField::new())
    }

    // int64 timeout = 3;


    pub fn get_timeout(&self) -> i64 {
        self.timeout
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: i64) {
        self.timeout = v;
    }
}

impl ::protobuf::Message for ExecSyncRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmd)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        for value in &self.cmd {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        for v in &self.cmd {
            os.write_string(2, &v)?;
        };
        if self.timeout != 0 {
            os.write_int64(3, self.timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecSyncRequest {
        ExecSyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &ExecSyncRequest| { &m.container_id },
                |m: &mut ExecSyncRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cmd",
                |m: &ExecSyncRequest| { &m.cmd },
                |m: &mut ExecSyncRequest| { &mut m.cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeout",
                |m: &ExecSyncRequest| { &m.timeout },
                |m: &mut ExecSyncRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecSyncRequest>(
                "ExecSyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecSyncRequest {
        static instance: ::protobuf::rt::LazyV2<ExecSyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecSyncRequest::new)
    }
}

impl ::protobuf::Clear for ExecSyncRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.cmd.clear();
        self.timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecSyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecSyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecSyncResponse {
    // message fields
    pub stdout: ::std::vec::Vec<u8>,
    pub stderr: ::std::vec::Vec<u8>,
    pub exit_code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecSyncResponse {
    fn default() -> &'a ExecSyncResponse {
        <ExecSyncResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecSyncResponse {
    pub fn new() -> ExecSyncResponse {
        ::std::default::Default::default()
    }

    // bytes stdout = 1;


    pub fn get_stdout(&self) -> &[u8] {
        &self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::vec::Vec<u8>) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stdout, ::std::vec::Vec::new())
    }

    // bytes stderr = 2;


    pub fn get_stderr(&self) -> &[u8] {
        &self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::vec::Vec<u8>) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stderr, ::std::vec::Vec::new())
    }

    // int32 exit_code = 3;


    pub fn get_exit_code(&self) -> i32 {
        self.exit_code
    }
    pub fn clear_exit_code(&mut self) {
        self.exit_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_code(&mut self, v: i32) {
        self.exit_code = v;
    }
}

impl ::protobuf::Message for ExecSyncResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stdout)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stderr)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exit_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.stderr);
        }
        if self.exit_code != 0 {
            my_size += ::protobuf::rt::value_size(3, self.exit_code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.stdout.is_empty() {
            os.write_bytes(1, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_bytes(2, &self.stderr)?;
        }
        if self.exit_code != 0 {
            os.write_int32(3, self.exit_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecSyncResponse {
        ExecSyncResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stdout",
                |m: &ExecSyncResponse| { &m.stdout },
                |m: &mut ExecSyncResponse| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "stderr",
                |m: &ExecSyncResponse| { &m.stderr },
                |m: &mut ExecSyncResponse| { &mut m.stderr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "exit_code",
                |m: &ExecSyncResponse| { &m.exit_code },
                |m: &mut ExecSyncResponse| { &mut m.exit_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecSyncResponse>(
                "ExecSyncResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecSyncResponse {
        static instance: ::protobuf::rt::LazyV2<ExecSyncResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecSyncResponse::new)
    }
}

impl ::protobuf::Clear for ExecSyncResponse {
    fn clear(&mut self) {
        self.stdout.clear();
        self.stderr.clear();
        self.exit_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecSyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecSyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub cmd: ::protobuf::RepeatedField<::std::string::String>,
    pub tty: bool,
    pub stdin: bool,
    pub stdout: bool,
    pub stderr: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecRequest {
    fn default() -> &'a ExecRequest {
        <ExecRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecRequest {
    pub fn new() -> ExecRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // repeated string cmd = 2;


    pub fn get_cmd(&self) -> &[::std::string::String] {
        &self.cmd
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cmd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmd(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cmd
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cmd, ::protobuf::RepeatedField::new())
    }

    // bool tty = 3;


    pub fn get_tty(&self) -> bool {
        self.tty
    }
    pub fn clear_tty(&mut self) {
        self.tty = false;
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = v;
    }

    // bool stdin = 4;


    pub fn get_stdin(&self) -> bool {
        self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = false;
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = v;
    }

    // bool stdout = 5;


    pub fn get_stdout(&self) -> bool {
        self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout = false;
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = v;
    }

    // bool stderr = 6;


    pub fn get_stderr(&self) -> bool {
        self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr = false;
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = v;
    }
}

impl ::protobuf::Message for ExecRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cmd)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        for value in &self.cmd {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.tty != false {
            my_size += 2;
        }
        if self.stdin != false {
            my_size += 2;
        }
        if self.stdout != false {
            my_size += 2;
        }
        if self.stderr != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        for v in &self.cmd {
            os.write_string(2, &v)?;
        };
        if self.tty != false {
            os.write_bool(3, self.tty)?;
        }
        if self.stdin != false {
            os.write_bool(4, self.stdin)?;
        }
        if self.stdout != false {
            os.write_bool(5, self.stdout)?;
        }
        if self.stderr != false {
            os.write_bool(6, self.stderr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecRequest {
        ExecRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &ExecRequest| { &m.container_id },
                |m: &mut ExecRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cmd",
                |m: &ExecRequest| { &m.cmd },
                |m: &mut ExecRequest| { &mut m.cmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &ExecRequest| { &m.tty },
                |m: &mut ExecRequest| { &mut m.tty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &ExecRequest| { &m.stdin },
                |m: &mut ExecRequest| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdout",
                |m: &ExecRequest| { &m.stdout },
                |m: &mut ExecRequest| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stderr",
                |m: &ExecRequest| { &m.stderr },
                |m: &mut ExecRequest| { &mut m.stderr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecRequest>(
                "ExecRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecRequest {
        static instance: ::protobuf::rt::LazyV2<ExecRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecRequest::new)
    }
}

impl ::protobuf::Clear for ExecRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.cmd.clear();
        self.tty = false;
        self.stdin = false;
        self.stdout = false;
        self.stderr = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecResponse {
    // message fields
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecResponse {
    fn default() -> &'a ExecResponse {
        <ExecResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecResponse {
    pub fn new() -> ExecResponse {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExecResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecResponse {
        ExecResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ExecResponse| { &m.url },
                |m: &mut ExecResponse| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecResponse>(
                "ExecResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecResponse {
        static instance: ::protobuf::rt::LazyV2<ExecResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecResponse::new)
    }
}

impl ::protobuf::Clear for ExecResponse {
    fn clear(&mut self) {
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttachRequest {
    // message fields
    pub container_id: ::std::string::String,
    pub stdin: bool,
    pub tty: bool,
    pub stdout: bool,
    pub stderr: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachRequest {
    fn default() -> &'a AttachRequest {
        <AttachRequest as ::protobuf::Message>::default_instance()
    }
}

impl AttachRequest {
    pub fn new() -> AttachRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }

    // bool stdin = 2;


    pub fn get_stdin(&self) -> bool {
        self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = false;
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = v;
    }

    // bool tty = 3;


    pub fn get_tty(&self) -> bool {
        self.tty
    }
    pub fn clear_tty(&mut self) {
        self.tty = false;
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = v;
    }

    // bool stdout = 4;


    pub fn get_stdout(&self) -> bool {
        self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout = false;
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = v;
    }

    // bool stderr = 5;


    pub fn get_stderr(&self) -> bool {
        self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr = false;
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = v;
    }
}

impl ::protobuf::Message for AttachRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        if self.stdin != false {
            my_size += 2;
        }
        if self.tty != false {
            my_size += 2;
        }
        if self.stdout != false {
            my_size += 2;
        }
        if self.stderr != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        if self.stdin != false {
            os.write_bool(2, self.stdin)?;
        }
        if self.tty != false {
            os.write_bool(3, self.tty)?;
        }
        if self.stdout != false {
            os.write_bool(4, self.stdout)?;
        }
        if self.stderr != false {
            os.write_bool(5, self.stderr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachRequest {
        AttachRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &AttachRequest| { &m.container_id },
                |m: &mut AttachRequest| { &mut m.container_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &AttachRequest| { &m.stdin },
                |m: &mut AttachRequest| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &AttachRequest| { &m.tty },
                |m: &mut AttachRequest| { &mut m.tty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdout",
                |m: &AttachRequest| { &m.stdout },
                |m: &mut AttachRequest| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stderr",
                |m: &AttachRequest| { &m.stderr },
                |m: &mut AttachRequest| { &mut m.stderr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachRequest>(
                "AttachRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachRequest {
        static instance: ::protobuf::rt::LazyV2<AttachRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachRequest::new)
    }
}

impl ::protobuf::Clear for AttachRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.stdin = false;
        self.tty = false;
        self.stdout = false;
        self.stderr = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttachResponse {
    // message fields
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachResponse {
    fn default() -> &'a AttachResponse {
        <AttachResponse as ::protobuf::Message>::default_instance()
    }
}

impl AttachResponse {
    pub fn new() -> AttachResponse {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttachResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachResponse {
        AttachResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &AttachResponse| { &m.url },
                |m: &mut AttachResponse| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachResponse>(
                "AttachResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachResponse {
        static instance: ::protobuf::rt::LazyV2<AttachResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachResponse::new)
    }
}

impl ::protobuf::Clear for AttachResponse {
    fn clear(&mut self) {
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortForwardRequest {
    // message fields
    pub pod_sandbox_id: ::std::string::String,
    pub port: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortForwardRequest {
    fn default() -> &'a PortForwardRequest {
        <PortForwardRequest as ::protobuf::Message>::default_instance()
    }
}

impl PortForwardRequest {
    pub fn new() -> PortForwardRequest {
        ::std::default::Default::default()
    }

    // string pod_sandbox_id = 1;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // repeated int32 port = 2;


    pub fn get_port(&self) -> &[i32] {
        &self.port
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::vec::Vec<i32>) {
        self.port = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.port
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.port, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PortForwardRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.port)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_sandbox_id);
        }
        for value in &self.port {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(1, &self.pod_sandbox_id)?;
        }
        for v in &self.port {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortForwardRequest {
        PortForwardRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &PortForwardRequest| { &m.pod_sandbox_id },
                |m: &mut PortForwardRequest| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &PortForwardRequest| { &m.port },
                |m: &mut PortForwardRequest| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortForwardRequest>(
                "PortForwardRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortForwardRequest {
        static instance: ::protobuf::rt::LazyV2<PortForwardRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortForwardRequest::new)
    }
}

impl ::protobuf::Clear for PortForwardRequest {
    fn clear(&mut self) {
        self.pod_sandbox_id.clear();
        self.port.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortForwardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortForwardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortForwardResponse {
    // message fields
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortForwardResponse {
    fn default() -> &'a PortForwardResponse {
        <PortForwardResponse as ::protobuf::Message>::default_instance()
    }
}

impl PortForwardResponse {
    pub fn new() -> PortForwardResponse {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortForwardResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortForwardResponse {
        PortForwardResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &PortForwardResponse| { &m.url },
                |m: &mut PortForwardResponse| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortForwardResponse>(
                "PortForwardResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortForwardResponse {
        static instance: ::protobuf::rt::LazyV2<PortForwardResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortForwardResponse::new)
    }
}

impl ::protobuf::Clear for PortForwardResponse {
    fn clear(&mut self) {
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortForwardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortForwardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageFilter {
    // message fields
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageFilter {
    fn default() -> &'a ImageFilter {
        <ImageFilter as ::protobuf::Message>::default_instance()
    }
}

impl ImageFilter {
    pub fn new() -> ImageFilter {
        ::std::default::Default::default()
    }

    // .runtime.v1.ImageSpec image = 1;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }
}

impl ::protobuf::Message for ImageFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageFilter {
        ImageFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &ImageFilter| { &m.image },
                |m: &mut ImageFilter| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageFilter>(
                "ImageFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageFilter {
        static instance: ::protobuf::rt::LazyV2<ImageFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageFilter::new)
    }
}

impl ::protobuf::Clear for ImageFilter {
    fn clear(&mut self) {
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListImagesRequest {
    // message fields
    pub filter: ::protobuf::SingularPtrField<ImageFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListImagesRequest {
    fn default() -> &'a ListImagesRequest {
        <ListImagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListImagesRequest {
    pub fn new() -> ListImagesRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ImageFilter filter = 1;


    pub fn get_filter(&self) -> &ImageFilter {
        self.filter.as_ref().unwrap_or_else(|| <ImageFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ImageFilter) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ImageFilter {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ImageFilter {
        self.filter.take().unwrap_or_else(|| ImageFilter::new())
    }
}

impl ::protobuf::Message for ListImagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListImagesRequest {
        ListImagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageFilter>>(
                "filter",
                |m: &ListImagesRequest| { &m.filter },
                |m: &mut ListImagesRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListImagesRequest>(
                "ListImagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListImagesRequest {
        static instance: ::protobuf::rt::LazyV2<ListImagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListImagesRequest::new)
    }
}

impl ::protobuf::Clear for ListImagesRequest {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListImagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListImagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    pub id: ::std::string::String,
    pub repo_tags: ::protobuf::RepeatedField<::std::string::String>,
    pub repo_digests: ::protobuf::RepeatedField<::std::string::String>,
    pub size: u64,
    pub uid: ::protobuf::SingularPtrField<Int64Value>,
    pub username: ::std::string::String,
    pub spec: ::protobuf::SingularPtrField<ImageSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated string repo_tags = 2;


    pub fn get_repo_tags(&self) -> &[::std::string::String] {
        &self.repo_tags
    }
    pub fn clear_repo_tags(&mut self) {
        self.repo_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_repo_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repo_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repo_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repo_tags
    }

    // Take field
    pub fn take_repo_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repo_tags, ::protobuf::RepeatedField::new())
    }

    // repeated string repo_digests = 3;


    pub fn get_repo_digests(&self) -> &[::std::string::String] {
        &self.repo_digests
    }
    pub fn clear_repo_digests(&mut self) {
        self.repo_digests.clear();
    }

    // Param is passed by value, moved
    pub fn set_repo_digests(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.repo_digests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_repo_digests(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.repo_digests
    }

    // Take field
    pub fn take_repo_digests(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.repo_digests, ::protobuf::RepeatedField::new())
    }

    // uint64 size = 4;


    pub fn get_size(&self) -> u64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = v;
    }

    // .runtime.v1.Int64Value uid = 5;


    pub fn get_uid(&self) -> &Int64Value {
        self.uid.as_ref().unwrap_or_else(|| <Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: Int64Value) {
        self.uid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut Int64Value {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> Int64Value {
        self.uid.take().unwrap_or_else(|| Int64Value::new())
    }

    // string username = 6;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // .runtime.v1.ImageSpec spec = 7;


    pub fn get_spec(&self) -> &ImageSpec {
        self.spec.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ImageSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ImageSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ImageSpec {
        self.spec.take().unwrap_or_else(|| ImageSpec::new())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.uid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repo_tags)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.repo_digests)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uid)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.repo_tags {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.repo_digests {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.uid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.username);
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.repo_tags {
            os.write_string(2, &v)?;
        };
        for v in &self.repo_digests {
            os.write_string(3, &v)?;
        };
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(6, &self.username)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Image| { &m.id },
                |m: &mut Image| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "repo_tags",
                |m: &Image| { &m.repo_tags },
                |m: &mut Image| { &mut m.repo_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "repo_digests",
                |m: &Image| { &m.repo_digests },
                |m: &mut Image| { &mut m.repo_digests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &Image| { &m.size },
                |m: &mut Image| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Int64Value>>(
                "uid",
                |m: &Image| { &m.uid },
                |m: &mut Image| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &Image| { &m.username },
                |m: &mut Image| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "spec",
                |m: &Image| { &m.spec },
                |m: &mut Image| { &mut m.spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.id.clear();
        self.repo_tags.clear();
        self.repo_digests.clear();
        self.size = 0;
        self.uid.clear();
        self.username.clear();
        self.spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListImagesResponse {
    // message fields
    pub images: ::protobuf::RepeatedField<Image>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListImagesResponse {
    fn default() -> &'a ListImagesResponse {
        <ListImagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListImagesResponse {
    pub fn new() -> ListImagesResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.Image images = 1;


    pub fn get_images(&self) -> &[Image] {
        &self.images
    }
    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::protobuf::RepeatedField<Image>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::protobuf::RepeatedField<Image> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::protobuf::RepeatedField<Image> {
        ::std::mem::replace(&mut self.images, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListImagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.images {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.images)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.images {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListImagesResponse {
        ListImagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "images",
                |m: &ListImagesResponse| { &m.images },
                |m: &mut ListImagesResponse| { &mut m.images },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListImagesResponse>(
                "ListImagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListImagesResponse {
        static instance: ::protobuf::rt::LazyV2<ListImagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListImagesResponse::new)
    }
}

impl ::protobuf::Clear for ListImagesResponse {
    fn clear(&mut self) {
        self.images.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListImagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListImagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageStatusRequest {
    // message fields
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    pub verbose: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageStatusRequest {
    fn default() -> &'a ImageStatusRequest {
        <ImageStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImageStatusRequest {
    pub fn new() -> ImageStatusRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ImageSpec image = 1;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }

    // bool verbose = 2;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }
}

impl ::protobuf::Message for ImageStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.verbose != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.verbose != false {
            os.write_bool(2, self.verbose)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageStatusRequest {
        ImageStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &ImageStatusRequest| { &m.image },
                |m: &mut ImageStatusRequest| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verbose",
                |m: &ImageStatusRequest| { &m.verbose },
                |m: &mut ImageStatusRequest| { &mut m.verbose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageStatusRequest>(
                "ImageStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageStatusRequest {
        static instance: ::protobuf::rt::LazyV2<ImageStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageStatusRequest::new)
    }
}

impl ::protobuf::Clear for ImageStatusRequest {
    fn clear(&mut self) {
        self.image.clear();
        self.verbose = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageStatusResponse {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    pub info: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageStatusResponse {
    fn default() -> &'a ImageStatusResponse {
        <ImageStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImageStatusResponse {
    pub fn new() -> ImageStatusResponse {
        ::std::default::Default::default()
    }

    // .runtime.v1.Image image = 1;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    // repeated .runtime.v1.ImageStatusResponse.InfoEntry info = 2;


    pub fn get_info(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.info, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ImageStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageStatusResponse {
        ImageStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &ImageStatusResponse| { &m.image },
                |m: &mut ImageStatusResponse| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &ImageStatusResponse| { &m.info },
                |m: &mut ImageStatusResponse| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageStatusResponse>(
                "ImageStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageStatusResponse {
        static instance: ::protobuf::rt::LazyV2<ImageStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageStatusResponse::new)
    }
}

impl ::protobuf::Clear for ImageStatusResponse {
    fn clear(&mut self) {
        self.image.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthConfig {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub auth: ::std::string::String,
    pub server_address: ::std::string::String,
    pub identity_token: ::std::string::String,
    pub registry_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthConfig {
    fn default() -> &'a AuthConfig {
        <AuthConfig as ::protobuf::Message>::default_instance()
    }
}

impl AuthConfig {
    pub fn new() -> AuthConfig {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string auth = 3;


    pub fn get_auth(&self) -> &str {
        &self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: ::std::string::String) {
        self.auth = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut ::std::string::String {
        &mut self.auth
    }

    // Take field
    pub fn take_auth(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth, ::std::string::String::new())
    }

    // string server_address = 4;


    pub fn get_server_address(&self) -> &str {
        &self.server_address
    }
    pub fn clear_server_address(&mut self) {
        self.server_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        &mut self.server_address
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_address, ::std::string::String::new())
    }

    // string identity_token = 5;


    pub fn get_identity_token(&self) -> &str {
        &self.identity_token
    }
    pub fn clear_identity_token(&mut self) {
        self.identity_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_token(&mut self, v: ::std::string::String) {
        self.identity_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_token(&mut self) -> &mut ::std::string::String {
        &mut self.identity_token
    }

    // Take field
    pub fn take_identity_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_token, ::std::string::String::new())
    }

    // string registry_token = 6;


    pub fn get_registry_token(&self) -> &str {
        &self.registry_token
    }
    pub fn clear_registry_token(&mut self) {
        self.registry_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_registry_token(&mut self, v: ::std::string::String) {
        self.registry_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registry_token(&mut self) -> &mut ::std::string::String {
        &mut self.registry_token
    }

    // Take field
    pub fn take_registry_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.registry_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_address)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.registry_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if !self.auth.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.auth);
        }
        if !self.server_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.server_address);
        }
        if !self.identity_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.identity_token);
        }
        if !self.registry_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.registry_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if !self.auth.is_empty() {
            os.write_string(3, &self.auth)?;
        }
        if !self.server_address.is_empty() {
            os.write_string(4, &self.server_address)?;
        }
        if !self.identity_token.is_empty() {
            os.write_string(5, &self.identity_token)?;
        }
        if !self.registry_token.is_empty() {
            os.write_string(6, &self.registry_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthConfig {
        AuthConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &AuthConfig| { &m.username },
                |m: &mut AuthConfig| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &AuthConfig| { &m.password },
                |m: &mut AuthConfig| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "auth",
                |m: &AuthConfig| { &m.auth },
                |m: &mut AuthConfig| { &mut m.auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_address",
                |m: &AuthConfig| { &m.server_address },
                |m: &mut AuthConfig| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_token",
                |m: &AuthConfig| { &m.identity_token },
                |m: &mut AuthConfig| { &mut m.identity_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "registry_token",
                |m: &AuthConfig| { &m.registry_token },
                |m: &mut AuthConfig| { &mut m.registry_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthConfig>(
                "AuthConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthConfig {
        static instance: ::protobuf::rt::LazyV2<AuthConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthConfig::new)
    }
}

impl ::protobuf::Clear for AuthConfig {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.auth.clear();
        self.server_address.clear();
        self.identity_token.clear();
        self.registry_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullImageRequest {
    // message fields
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    pub auth: ::protobuf::SingularPtrField<AuthConfig>,
    pub sandbox_config: ::protobuf::SingularPtrField<PodSandboxConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullImageRequest {
    fn default() -> &'a PullImageRequest {
        <PullImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullImageRequest {
    pub fn new() -> PullImageRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ImageSpec image = 1;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }

    // .runtime.v1.AuthConfig auth = 2;


    pub fn get_auth(&self) -> &AuthConfig {
        self.auth.as_ref().unwrap_or_else(|| <AuthConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    pub fn has_auth(&self) -> bool {
        self.auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: AuthConfig) {
        self.auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut AuthConfig {
        if self.auth.is_none() {
            self.auth.set_default();
        }
        self.auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth(&mut self) -> AuthConfig {
        self.auth.take().unwrap_or_else(|| AuthConfig::new())
    }

    // .runtime.v1.PodSandboxConfig sandbox_config = 3;


    pub fn get_sandbox_config(&self) -> &PodSandboxConfig {
        self.sandbox_config.as_ref().unwrap_or_else(|| <PodSandboxConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sandbox_config(&mut self) {
        self.sandbox_config.clear();
    }

    pub fn has_sandbox_config(&self) -> bool {
        self.sandbox_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sandbox_config(&mut self, v: PodSandboxConfig) {
        self.sandbox_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sandbox_config(&mut self) -> &mut PodSandboxConfig {
        if self.sandbox_config.is_none() {
            self.sandbox_config.set_default();
        }
        self.sandbox_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_sandbox_config(&mut self) -> PodSandboxConfig {
        self.sandbox_config.take().unwrap_or_else(|| PodSandboxConfig::new())
    }
}

impl ::protobuf::Message for PullImageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sandbox_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sandbox_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sandbox_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.auth.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sandbox_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullImageRequest {
        PullImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &PullImageRequest| { &m.image },
                |m: &mut PullImageRequest| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthConfig>>(
                "auth",
                |m: &PullImageRequest| { &m.auth },
                |m: &mut PullImageRequest| { &mut m.auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSandboxConfig>>(
                "sandbox_config",
                |m: &PullImageRequest| { &m.sandbox_config },
                |m: &mut PullImageRequest| { &mut m.sandbox_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullImageRequest>(
                "PullImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullImageRequest {
        static instance: ::protobuf::rt::LazyV2<PullImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullImageRequest::new)
    }
}

impl ::protobuf::Clear for PullImageRequest {
    fn clear(&mut self) {
        self.image.clear();
        self.auth.clear();
        self.sandbox_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullImageResponse {
    // message fields
    pub image_ref: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullImageResponse {
    fn default() -> &'a PullImageResponse {
        <PullImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullImageResponse {
    pub fn new() -> PullImageResponse {
        ::std::default::Default::default()
    }

    // string image_ref = 1;


    pub fn get_image_ref(&self) -> &str {
        &self.image_ref
    }
    pub fn clear_image_ref(&mut self) {
        self.image_ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_ref(&mut self, v: ::std::string::String) {
        self.image_ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_ref(&mut self) -> &mut ::std::string::String {
        &mut self.image_ref
    }

    // Take field
    pub fn take_image_ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_ref, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PullImageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_ref)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image_ref.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.image_ref);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image_ref.is_empty() {
            os.write_string(1, &self.image_ref)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullImageResponse {
        PullImageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_ref",
                |m: &PullImageResponse| { &m.image_ref },
                |m: &mut PullImageResponse| { &mut m.image_ref },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullImageResponse>(
                "PullImageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullImageResponse {
        static instance: ::protobuf::rt::LazyV2<PullImageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullImageResponse::new)
    }
}

impl ::protobuf::Clear for PullImageResponse {
    fn clear(&mut self) {
        self.image_ref.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullImageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveImageRequest {
    // message fields
    pub image: ::protobuf::SingularPtrField<ImageSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveImageRequest {
    fn default() -> &'a RemoveImageRequest {
        <RemoveImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveImageRequest {
    pub fn new() -> RemoveImageRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ImageSpec image = 1;


    pub fn get_image(&self) -> &ImageSpec {
        self.image.as_ref().unwrap_or_else(|| <ImageSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageSpec) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ImageSpec {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ImageSpec {
        self.image.take().unwrap_or_else(|| ImageSpec::new())
    }
}

impl ::protobuf::Message for RemoveImageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveImageRequest {
        RemoveImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageSpec>>(
                "image",
                |m: &RemoveImageRequest| { &m.image },
                |m: &mut RemoveImageRequest| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveImageRequest>(
                "RemoveImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveImageRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveImageRequest::new)
    }
}

impl ::protobuf::Clear for RemoveImageRequest {
    fn clear(&mut self) {
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveImageResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveImageResponse {
    fn default() -> &'a RemoveImageResponse {
        <RemoveImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemoveImageResponse {
    pub fn new() -> RemoveImageResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveImageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveImageResponse {
        RemoveImageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveImageResponse>(
                "RemoveImageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveImageResponse {
        static instance: ::protobuf::rt::LazyV2<RemoveImageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveImageResponse::new)
    }
}

impl ::protobuf::Clear for RemoveImageResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveImageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkConfig {
    // message fields
    pub pod_cidr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkConfig {
    fn default() -> &'a NetworkConfig {
        <NetworkConfig as ::protobuf::Message>::default_instance()
    }
}

impl NetworkConfig {
    pub fn new() -> NetworkConfig {
        ::std::default::Default::default()
    }

    // string pod_cidr = 1;


    pub fn get_pod_cidr(&self) -> &str {
        &self.pod_cidr
    }
    pub fn clear_pod_cidr(&mut self) {
        self.pod_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_cidr(&mut self, v: ::std::string::String) {
        self.pod_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.pod_cidr
    }

    // Take field
    pub fn take_pod_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_cidr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NetworkConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_cidr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pod_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pod_cidr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pod_cidr.is_empty() {
            os.write_string(1, &self.pod_cidr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkConfig {
        NetworkConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_cidr",
                |m: &NetworkConfig| { &m.pod_cidr },
                |m: &mut NetworkConfig| { &mut m.pod_cidr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkConfig>(
                "NetworkConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkConfig {
        static instance: ::protobuf::rt::LazyV2<NetworkConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkConfig::new)
    }
}

impl ::protobuf::Clear for NetworkConfig {
    fn clear(&mut self) {
        self.pod_cidr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeConfig {
    // message fields
    pub network_config: ::protobuf::SingularPtrField<NetworkConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeConfig {
    fn default() -> &'a RuntimeConfig {
        <RuntimeConfig as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeConfig {
    pub fn new() -> RuntimeConfig {
        ::std::default::Default::default()
    }

    // .runtime.v1.NetworkConfig network_config = 1;


    pub fn get_network_config(&self) -> &NetworkConfig {
        self.network_config.as_ref().unwrap_or_else(|| <NetworkConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_config(&mut self) {
        self.network_config.clear();
    }

    pub fn has_network_config(&self) -> bool {
        self.network_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config(&mut self, v: NetworkConfig) {
        self.network_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_config(&mut self) -> &mut NetworkConfig {
        if self.network_config.is_none() {
            self.network_config.set_default();
        }
        self.network_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_config(&mut self) -> NetworkConfig {
        self.network_config.take().unwrap_or_else(|| NetworkConfig::new())
    }
}

impl ::protobuf::Message for RuntimeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.network_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.network_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.network_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeConfig {
        RuntimeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkConfig>>(
                "network_config",
                |m: &RuntimeConfig| { &m.network_config },
                |m: &mut RuntimeConfig| { &mut m.network_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeConfig>(
                "RuntimeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeConfig {
        static instance: ::protobuf::rt::LazyV2<RuntimeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeConfig::new)
    }
}

impl ::protobuf::Clear for RuntimeConfig {
    fn clear(&mut self) {
        self.network_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRuntimeConfigRequest {
    // message fields
    pub runtime_config: ::protobuf::SingularPtrField<RuntimeConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRuntimeConfigRequest {
    fn default() -> &'a UpdateRuntimeConfigRequest {
        <UpdateRuntimeConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRuntimeConfigRequest {
    pub fn new() -> UpdateRuntimeConfigRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.RuntimeConfig runtime_config = 1;


    pub fn get_runtime_config(&self) -> &RuntimeConfig {
        self.runtime_config.as_ref().unwrap_or_else(|| <RuntimeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_config(&mut self) {
        self.runtime_config.clear();
    }

    pub fn has_runtime_config(&self) -> bool {
        self.runtime_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_config(&mut self, v: RuntimeConfig) {
        self.runtime_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_config(&mut self) -> &mut RuntimeConfig {
        if self.runtime_config.is_none() {
            self.runtime_config.set_default();
        }
        self.runtime_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_config(&mut self) -> RuntimeConfig {
        self.runtime_config.take().unwrap_or_else(|| RuntimeConfig::new())
    }
}

impl ::protobuf::Message for UpdateRuntimeConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.runtime_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.runtime_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.runtime_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRuntimeConfigRequest {
        UpdateRuntimeConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeConfig>>(
                "runtime_config",
                |m: &UpdateRuntimeConfigRequest| { &m.runtime_config },
                |m: &mut UpdateRuntimeConfigRequest| { &mut m.runtime_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRuntimeConfigRequest>(
                "UpdateRuntimeConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRuntimeConfigRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRuntimeConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRuntimeConfigRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRuntimeConfigRequest {
    fn clear(&mut self) {
        self.runtime_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRuntimeConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRuntimeConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRuntimeConfigResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRuntimeConfigResponse {
    fn default() -> &'a UpdateRuntimeConfigResponse {
        <UpdateRuntimeConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRuntimeConfigResponse {
    pub fn new() -> UpdateRuntimeConfigResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateRuntimeConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRuntimeConfigResponse {
        UpdateRuntimeConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRuntimeConfigResponse>(
                "UpdateRuntimeConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRuntimeConfigResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateRuntimeConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRuntimeConfigResponse::new)
    }
}

impl ::protobuf::Clear for UpdateRuntimeConfigResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRuntimeConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRuntimeConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeCondition {
    // message fields
    pub field_type: ::std::string::String,
    pub status: bool,
    pub reason: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeCondition {
    fn default() -> &'a RuntimeCondition {
        <RuntimeCondition as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeCondition {
    pub fn new() -> RuntimeCondition {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // bool status = 2;


    pub fn get_status(&self) -> bool {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = false;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: bool) {
        self.status = v;
    }

    // string reason = 3;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }

    // string message = 4;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.status = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if self.status != false {
            my_size += 2;
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.reason);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if self.status != false {
            os.write_bool(2, self.status)?;
        }
        if !self.reason.is_empty() {
            os.write_string(3, &self.reason)?;
        }
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeCondition {
        RuntimeCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &RuntimeCondition| { &m.field_type },
                |m: &mut RuntimeCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "status",
                |m: &RuntimeCondition| { &m.status },
                |m: &mut RuntimeCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &RuntimeCondition| { &m.reason },
                |m: &mut RuntimeCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &RuntimeCondition| { &m.message },
                |m: &mut RuntimeCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeCondition>(
                "RuntimeCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeCondition {
        static instance: ::protobuf::rt::LazyV2<RuntimeCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeCondition::new)
    }
}

impl ::protobuf::Clear for RuntimeCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status = false;
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeStatus {
    // message fields
    pub conditions: ::protobuf::RepeatedField<RuntimeCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeStatus {
    fn default() -> &'a RuntimeStatus {
        <RuntimeStatus as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeStatus {
    pub fn new() -> RuntimeStatus {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.RuntimeCondition conditions = 1;


    pub fn get_conditions(&self) -> &[RuntimeCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<RuntimeCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<RuntimeCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RuntimeStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.conditions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeStatus {
        RuntimeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeCondition>>(
                "conditions",
                |m: &RuntimeStatus| { &m.conditions },
                |m: &mut RuntimeStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeStatus>(
                "RuntimeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeStatus {
        static instance: ::protobuf::rt::LazyV2<RuntimeStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeStatus::new)
    }
}

impl ::protobuf::Clear for RuntimeStatus {
    fn clear(&mut self) {
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusRequest {
    // message fields
    pub verbose: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }

    // bool verbose = 1;


    pub fn get_verbose(&self) -> bool {
        self.verbose
    }
    pub fn clear_verbose(&mut self) {
        self.verbose = false;
    }

    // Param is passed by value, moved
    pub fn set_verbose(&mut self, v: bool) {
        self.verbose = v;
    }
}

impl ::protobuf::Message for StatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verbose = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.verbose != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.verbose != false {
            os.write_bool(1, self.verbose)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verbose",
                |m: &StatusRequest| { &m.verbose },
                |m: &mut StatusRequest| { &mut m.verbose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusRequest>(
                "StatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusRequest {
        static instance: ::protobuf::rt::LazyV2<StatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusRequest::new)
    }
}

impl ::protobuf::Clear for StatusRequest {
    fn clear(&mut self) {
        self.verbose = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<RuntimeStatus>,
    pub info: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusResponse {
    fn default() -> &'a StatusResponse {
        <StatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusResponse {
    pub fn new() -> StatusResponse {
        ::std::default::Default::default()
    }

    // .runtime.v1.RuntimeStatus status = 1;


    pub fn get_status(&self) -> &RuntimeStatus {
        self.status.as_ref().unwrap_or_else(|| <RuntimeStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RuntimeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut RuntimeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> RuntimeStatus {
        self.status.take().unwrap_or_else(|| RuntimeStatus::new())
    }

    // repeated .runtime.v1.StatusResponse.InfoEntry info = 2;


    pub fn get_info(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.info, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for StatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.info, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusResponse {
        StatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeStatus>>(
                "status",
                |m: &StatusResponse| { &m.status },
                |m: &mut StatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &StatusResponse| { &m.info },
                |m: &mut StatusResponse| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusResponse>(
                "StatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusResponse {
        static instance: ::protobuf::rt::LazyV2<StatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusResponse::new)
    }
}

impl ::protobuf::Clear for StatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageFsInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageFsInfoRequest {
    fn default() -> &'a ImageFsInfoRequest {
        <ImageFsInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImageFsInfoRequest {
    pub fn new() -> ImageFsInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ImageFsInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageFsInfoRequest {
        ImageFsInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageFsInfoRequest>(
                "ImageFsInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageFsInfoRequest {
        static instance: ::protobuf::rt::LazyV2<ImageFsInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageFsInfoRequest::new)
    }
}

impl ::protobuf::Clear for ImageFsInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageFsInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageFsInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UInt64Value {
    // message fields
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UInt64Value {
    fn default() -> &'a UInt64Value {
        <UInt64Value as ::protobuf::Message>::default_instance()
    }
}

impl UInt64Value {
    pub fn new() -> UInt64Value {
        ::std::default::Default::default()
    }

    // uint64 value = 1;


    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for UInt64Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint64(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UInt64Value {
        UInt64Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "value",
                |m: &UInt64Value| { &m.value },
                |m: &mut UInt64Value| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UInt64Value>(
                "UInt64Value",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UInt64Value {
        static instance: ::protobuf::rt::LazyV2<UInt64Value> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UInt64Value::new)
    }
}

impl ::protobuf::Clear for UInt64Value {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UInt64Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UInt64Value {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilesystemIdentifier {
    // message fields
    pub mountpoint: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilesystemIdentifier {
    fn default() -> &'a FilesystemIdentifier {
        <FilesystemIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl FilesystemIdentifier {
    pub fn new() -> FilesystemIdentifier {
        ::std::default::Default::default()
    }

    // string mountpoint = 1;


    pub fn get_mountpoint(&self) -> &str {
        &self.mountpoint
    }
    pub fn clear_mountpoint(&mut self) {
        self.mountpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_mountpoint(&mut self, v: ::std::string::String) {
        self.mountpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountpoint(&mut self) -> &mut ::std::string::String {
        &mut self.mountpoint
    }

    // Take field
    pub fn take_mountpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mountpoint, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilesystemIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mountpoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mountpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mountpoint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mountpoint.is_empty() {
            os.write_string(1, &self.mountpoint)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilesystemIdentifier {
        FilesystemIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mountpoint",
                |m: &FilesystemIdentifier| { &m.mountpoint },
                |m: &mut FilesystemIdentifier| { &mut m.mountpoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilesystemIdentifier>(
                "FilesystemIdentifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilesystemIdentifier {
        static instance: ::protobuf::rt::LazyV2<FilesystemIdentifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilesystemIdentifier::new)
    }
}

impl ::protobuf::Clear for FilesystemIdentifier {
    fn clear(&mut self) {
        self.mountpoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilesystemIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesystemIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilesystemUsage {
    // message fields
    pub timestamp: i64,
    pub fs_id: ::protobuf::SingularPtrField<FilesystemIdentifier>,
    pub used_bytes: ::protobuf::SingularPtrField<UInt64Value>,
    pub inodes_used: ::protobuf::SingularPtrField<UInt64Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilesystemUsage {
    fn default() -> &'a FilesystemUsage {
        <FilesystemUsage as ::protobuf::Message>::default_instance()
    }
}

impl FilesystemUsage {
    pub fn new() -> FilesystemUsage {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // .runtime.v1.FilesystemIdentifier fs_id = 2;


    pub fn get_fs_id(&self) -> &FilesystemIdentifier {
        self.fs_id.as_ref().unwrap_or_else(|| <FilesystemIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fs_id(&mut self) {
        self.fs_id.clear();
    }

    pub fn has_fs_id(&self) -> bool {
        self.fs_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs_id(&mut self, v: FilesystemIdentifier) {
        self.fs_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs_id(&mut self) -> &mut FilesystemIdentifier {
        if self.fs_id.is_none() {
            self.fs_id.set_default();
        }
        self.fs_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs_id(&mut self) -> FilesystemIdentifier {
        self.fs_id.take().unwrap_or_else(|| FilesystemIdentifier::new())
    }

    // .runtime.v1.UInt64Value used_bytes = 3;


    pub fn get_used_bytes(&self) -> &UInt64Value {
        self.used_bytes.as_ref().unwrap_or_else(|| <UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_used_bytes(&mut self) {
        self.used_bytes.clear();
    }

    pub fn has_used_bytes(&self) -> bool {
        self.used_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used_bytes(&mut self, v: UInt64Value) {
        self.used_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_used_bytes(&mut self) -> &mut UInt64Value {
        if self.used_bytes.is_none() {
            self.used_bytes.set_default();
        }
        self.used_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_used_bytes(&mut self) -> UInt64Value {
        self.used_bytes.take().unwrap_or_else(|| UInt64Value::new())
    }

    // .runtime.v1.UInt64Value inodes_used = 4;


    pub fn get_inodes_used(&self) -> &UInt64Value {
        self.inodes_used.as_ref().unwrap_or_else(|| <UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_inodes_used(&mut self) {
        self.inodes_used.clear();
    }

    pub fn has_inodes_used(&self) -> bool {
        self.inodes_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inodes_used(&mut self, v: UInt64Value) {
        self.inodes_used = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inodes_used(&mut self) -> &mut UInt64Value {
        if self.inodes_used.is_none() {
            self.inodes_used.set_default();
        }
        self.inodes_used.as_mut().unwrap()
    }

    // Take field
    pub fn take_inodes_used(&mut self) -> UInt64Value {
        self.inodes_used.take().unwrap_or_else(|| UInt64Value::new())
    }
}

impl ::protobuf::Message for FilesystemUsage {
    fn is_initialized(&self) -> bool {
        for v in &self.fs_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.used_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inodes_used {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.used_bytes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inodes_used)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fs_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.used_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inodes_used.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if let Some(ref v) = self.fs_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.used_bytes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inodes_used.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilesystemUsage {
        FilesystemUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &FilesystemUsage| { &m.timestamp },
                |m: &mut FilesystemUsage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilesystemIdentifier>>(
                "fs_id",
                |m: &FilesystemUsage| { &m.fs_id },
                |m: &mut FilesystemUsage| { &mut m.fs_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt64Value>>(
                "used_bytes",
                |m: &FilesystemUsage| { &m.used_bytes },
                |m: &mut FilesystemUsage| { &mut m.used_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt64Value>>(
                "inodes_used",
                |m: &FilesystemUsage| { &m.inodes_used },
                |m: &mut FilesystemUsage| { &mut m.inodes_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilesystemUsage>(
                "FilesystemUsage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilesystemUsage {
        static instance: ::protobuf::rt::LazyV2<FilesystemUsage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilesystemUsage::new)
    }
}

impl ::protobuf::Clear for FilesystemUsage {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.fs_id.clear();
        self.used_bytes.clear();
        self.inodes_used.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilesystemUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesystemUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageFsInfoResponse {
    // message fields
    pub image_filesystems: ::protobuf::RepeatedField<FilesystemUsage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageFsInfoResponse {
    fn default() -> &'a ImageFsInfoResponse {
        <ImageFsInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImageFsInfoResponse {
    pub fn new() -> ImageFsInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.FilesystemUsage image_filesystems = 1;


    pub fn get_image_filesystems(&self) -> &[FilesystemUsage] {
        &self.image_filesystems
    }
    pub fn clear_image_filesystems(&mut self) {
        self.image_filesystems.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_filesystems(&mut self, v: ::protobuf::RepeatedField<FilesystemUsage>) {
        self.image_filesystems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_image_filesystems(&mut self) -> &mut ::protobuf::RepeatedField<FilesystemUsage> {
        &mut self.image_filesystems
    }

    // Take field
    pub fn take_image_filesystems(&mut self) -> ::protobuf::RepeatedField<FilesystemUsage> {
        ::std::mem::replace(&mut self.image_filesystems, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ImageFsInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.image_filesystems {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image_filesystems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.image_filesystems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.image_filesystems {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageFsInfoResponse {
        ImageFsInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilesystemUsage>>(
                "image_filesystems",
                |m: &ImageFsInfoResponse| { &m.image_filesystems },
                |m: &mut ImageFsInfoResponse| { &mut m.image_filesystems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageFsInfoResponse>(
                "ImageFsInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageFsInfoResponse {
        static instance: ::protobuf::rt::LazyV2<ImageFsInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageFsInfoResponse::new)
    }
}

impl ::protobuf::Clear for ImageFsInfoResponse {
    fn clear(&mut self) {
        self.image_filesystems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageFsInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageFsInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatsRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatsRequest {
    fn default() -> &'a ContainerStatsRequest {
        <ContainerStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatsRequest {
    pub fn new() -> ContainerStatsRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatsRequest {
        ContainerStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &ContainerStatsRequest| { &m.container_id },
                |m: &mut ContainerStatsRequest| { &mut m.container_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatsRequest>(
                "ContainerStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatsRequest {
        static instance: ::protobuf::rt::LazyV2<ContainerStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatsRequest::new)
    }
}

impl ::protobuf::Clear for ContainerStatsRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatsResponse {
    // message fields
    pub stats: ::protobuf::SingularPtrField<ContainerStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatsResponse {
    fn default() -> &'a ContainerStatsResponse {
        <ContainerStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatsResponse {
    pub fn new() -> ContainerStatsResponse {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerStats stats = 1;


    pub fn get_stats(&self) -> &ContainerStats {
        self.stats.as_ref().unwrap_or_else(|| <ContainerStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ContainerStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut ContainerStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> ContainerStats {
        self.stats.take().unwrap_or_else(|| ContainerStats::new())
    }
}

impl ::protobuf::Message for ContainerStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatsResponse {
        ContainerStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStats>>(
                "stats",
                |m: &ContainerStatsResponse| { &m.stats },
                |m: &mut ContainerStatsResponse| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatsResponse>(
                "ContainerStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatsResponse {
        static instance: ::protobuf::rt::LazyV2<ContainerStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatsResponse::new)
    }
}

impl ::protobuf::Clear for ContainerStatsResponse {
    fn clear(&mut self) {
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListContainerStatsRequest {
    // message fields
    pub filter: ::protobuf::SingularPtrField<ContainerStatsFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListContainerStatsRequest {
    fn default() -> &'a ListContainerStatsRequest {
        <ListContainerStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListContainerStatsRequest {
    pub fn new() -> ListContainerStatsRequest {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerStatsFilter filter = 1;


    pub fn get_filter(&self) -> &ContainerStatsFilter {
        self.filter.as_ref().unwrap_or_else(|| <ContainerStatsFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ContainerStatsFilter) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ContainerStatsFilter {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ContainerStatsFilter {
        self.filter.take().unwrap_or_else(|| ContainerStatsFilter::new())
    }
}

impl ::protobuf::Message for ListContainerStatsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListContainerStatsRequest {
        ListContainerStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatsFilter>>(
                "filter",
                |m: &ListContainerStatsRequest| { &m.filter },
                |m: &mut ListContainerStatsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListContainerStatsRequest>(
                "ListContainerStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListContainerStatsRequest {
        static instance: ::protobuf::rt::LazyV2<ListContainerStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListContainerStatsRequest::new)
    }
}

impl ::protobuf::Clear for ListContainerStatsRequest {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListContainerStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListContainerStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatsFilter {
    // message fields
    pub id: ::std::string::String,
    pub pod_sandbox_id: ::std::string::String,
    pub label_selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatsFilter {
    fn default() -> &'a ContainerStatsFilter {
        <ContainerStatsFilter as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatsFilter {
    pub fn new() -> ContainerStatsFilter {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string pod_sandbox_id = 2;


    pub fn get_pod_sandbox_id(&self) -> &str {
        &self.pod_sandbox_id
    }
    pub fn clear_pod_sandbox_id(&mut self) {
        self.pod_sandbox_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pod_sandbox_id(&mut self, v: ::std::string::String) {
        self.pod_sandbox_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pod_sandbox_id(&mut self) -> &mut ::std::string::String {
        &mut self.pod_sandbox_id
    }

    // Take field
    pub fn take_pod_sandbox_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pod_sandbox_id, ::std::string::String::new())
    }

    // repeated .runtime.v1.ContainerStatsFilter.LabelSelectorEntry label_selector = 3;


    pub fn get_label_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.label_selector
    }
    pub fn clear_label_selector(&mut self) {
        self.label_selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.label_selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.label_selector
    }

    // Take field
    pub fn take_label_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.label_selector, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ContainerStatsFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pod_sandbox_id)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.label_selector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.pod_sandbox_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pod_sandbox_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.label_selector);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.pod_sandbox_id.is_empty() {
            os.write_string(2, &self.pod_sandbox_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.label_selector, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatsFilter {
        ContainerStatsFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ContainerStatsFilter| { &m.id },
                |m: &mut ContainerStatsFilter| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pod_sandbox_id",
                |m: &ContainerStatsFilter| { &m.pod_sandbox_id },
                |m: &mut ContainerStatsFilter| { &mut m.pod_sandbox_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "label_selector",
                |m: &ContainerStatsFilter| { &m.label_selector },
                |m: &mut ContainerStatsFilter| { &mut m.label_selector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatsFilter>(
                "ContainerStatsFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatsFilter {
        static instance: ::protobuf::rt::LazyV2<ContainerStatsFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatsFilter::new)
    }
}

impl ::protobuf::Clear for ContainerStatsFilter {
    fn clear(&mut self) {
        self.id.clear();
        self.pod_sandbox_id.clear();
        self.label_selector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatsFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatsFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListContainerStatsResponse {
    // message fields
    pub stats: ::protobuf::RepeatedField<ContainerStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListContainerStatsResponse {
    fn default() -> &'a ListContainerStatsResponse {
        <ListContainerStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListContainerStatsResponse {
    pub fn new() -> ListContainerStatsResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.v1.ContainerStats stats = 1;


    pub fn get_stats(&self) -> &[ContainerStats] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<ContainerStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<ContainerStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListContainerStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListContainerStatsResponse {
        ListContainerStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStats>>(
                "stats",
                |m: &ListContainerStatsResponse| { &m.stats },
                |m: &mut ListContainerStatsResponse| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListContainerStatsResponse>(
                "ListContainerStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListContainerStatsResponse {
        static instance: ::protobuf::rt::LazyV2<ListContainerStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListContainerStatsResponse::new)
    }
}

impl ::protobuf::Clear for ListContainerStatsResponse {
    fn clear(&mut self) {
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListContainerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListContainerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerAttributes {
    // message fields
    pub id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerAttributes {
    fn default() -> &'a ContainerAttributes {
        <ContainerAttributes as ::protobuf::Message>::default_instance()
    }
}

impl ContainerAttributes {
    pub fn new() -> ContainerAttributes {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .runtime.v1.ContainerMetadata metadata = 2;


    pub fn get_metadata(&self) -> &ContainerMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ContainerMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ContainerMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ContainerMetadata {
        self.metadata.take().unwrap_or_else(|| ContainerMetadata::new())
    }

    // repeated .runtime.v1.ContainerAttributes.LabelsEntry labels = 3;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .runtime.v1.ContainerAttributes.AnnotationsEntry annotations = 4;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ContainerAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.annotations);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.annotations, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerAttributes {
        ContainerAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ContainerAttributes| { &m.id },
                |m: &mut ContainerAttributes| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "metadata",
                |m: &ContainerAttributes| { &m.metadata },
                |m: &mut ContainerAttributes| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &ContainerAttributes| { &m.labels },
                |m: &mut ContainerAttributes| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ContainerAttributes| { &m.annotations },
                |m: &mut ContainerAttributes| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerAttributes>(
                "ContainerAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerAttributes {
        static instance: ::protobuf::rt::LazyV2<ContainerAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerAttributes::new)
    }
}

impl ::protobuf::Clear for ContainerAttributes {
    fn clear(&mut self) {
        self.id.clear();
        self.metadata.clear();
        self.labels.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStats {
    // message fields
    pub attributes: ::protobuf::SingularPtrField<ContainerAttributes>,
    pub cpu: ::protobuf::SingularPtrField<CpuUsage>,
    pub memory: ::protobuf::SingularPtrField<MemoryUsage>,
    pub writable_layer: ::protobuf::SingularPtrField<FilesystemUsage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStats {
    fn default() -> &'a ContainerStats {
        <ContainerStats as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStats {
    pub fn new() -> ContainerStats {
        ::std::default::Default::default()
    }

    // .runtime.v1.ContainerAttributes attributes = 1;


    pub fn get_attributes(&self) -> &ContainerAttributes {
        self.attributes.as_ref().unwrap_or_else(|| <ContainerAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ContainerAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut ContainerAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> ContainerAttributes {
        self.attributes.take().unwrap_or_else(|| ContainerAttributes::new())
    }

    // .runtime.v1.CpuUsage cpu = 2;


    pub fn get_cpu(&self) -> &CpuUsage {
        self.cpu.as_ref().unwrap_or_else(|| <CpuUsage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    pub fn has_cpu(&self) -> bool {
        self.cpu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: CpuUsage) {
        self.cpu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu(&mut self) -> &mut CpuUsage {
        if self.cpu.is_none() {
            self.cpu.set_default();
        }
        self.cpu.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu(&mut self) -> CpuUsage {
        self.cpu.take().unwrap_or_else(|| CpuUsage::new())
    }

    // .runtime.v1.MemoryUsage memory = 3;


    pub fn get_memory(&self) -> &MemoryUsage {
        self.memory.as_ref().unwrap_or_else(|| <MemoryUsage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_memory(&mut self) {
        self.memory.clear();
    }

    pub fn has_memory(&self) -> bool {
        self.memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: MemoryUsage) {
        self.memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory(&mut self) -> &mut MemoryUsage {
        if self.memory.is_none() {
            self.memory.set_default();
        }
        self.memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory(&mut self) -> MemoryUsage {
        self.memory.take().unwrap_or_else(|| MemoryUsage::new())
    }

    // .runtime.v1.FilesystemUsage writable_layer = 4;


    pub fn get_writable_layer(&self) -> &FilesystemUsage {
        self.writable_layer.as_ref().unwrap_or_else(|| <FilesystemUsage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_writable_layer(&mut self) {
        self.writable_layer.clear();
    }

    pub fn has_writable_layer(&self) -> bool {
        self.writable_layer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writable_layer(&mut self, v: FilesystemUsage) {
        self.writable_layer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writable_layer(&mut self) -> &mut FilesystemUsage {
        if self.writable_layer.is_none() {
            self.writable_layer.set_default();
        }
        self.writable_layer.as_mut().unwrap()
    }

    // Take field
    pub fn take_writable_layer(&mut self) -> FilesystemUsage {
        self.writable_layer.take().unwrap_or_else(|| FilesystemUsage::new())
    }
}

impl ::protobuf::Message for ContainerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.writable_layer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.writable_layer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.writable_layer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.writable_layer.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStats {
        ContainerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerAttributes>>(
                "attributes",
                |m: &ContainerStats| { &m.attributes },
                |m: &mut ContainerStats| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuUsage>>(
                "cpu",
                |m: &ContainerStats| { &m.cpu },
                |m: &mut ContainerStats| { &mut m.cpu },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MemoryUsage>>(
                "memory",
                |m: &ContainerStats| { &m.memory },
                |m: &mut ContainerStats| { &mut m.memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilesystemUsage>>(
                "writable_layer",
                |m: &ContainerStats| { &m.writable_layer },
                |m: &mut ContainerStats| { &mut m.writable_layer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStats>(
                "ContainerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStats {
        static instance: ::protobuf::rt::LazyV2<ContainerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStats::new)
    }
}

impl ::protobuf::Clear for ContainerStats {
    fn clear(&mut self) {
        self.attributes.clear();
        self.cpu.clear();
        self.memory.clear();
        self.writable_layer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CpuUsage {
    // message fields
    pub timestamp: i64,
    pub usage_core_nano_seconds: ::protobuf::SingularPtrField<UInt64Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuUsage {
    fn default() -> &'a CpuUsage {
        <CpuUsage as ::protobuf::Message>::default_instance()
    }
}

impl CpuUsage {
    pub fn new() -> CpuUsage {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // .runtime.v1.UInt64Value usage_core_nano_seconds = 2;


    pub fn get_usage_core_nano_seconds(&self) -> &UInt64Value {
        self.usage_core_nano_seconds.as_ref().unwrap_or_else(|| <UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_usage_core_nano_seconds(&mut self) {
        self.usage_core_nano_seconds.clear();
    }

    pub fn has_usage_core_nano_seconds(&self) -> bool {
        self.usage_core_nano_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage_core_nano_seconds(&mut self, v: UInt64Value) {
        self.usage_core_nano_seconds = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage_core_nano_seconds(&mut self) -> &mut UInt64Value {
        if self.usage_core_nano_seconds.is_none() {
            self.usage_core_nano_seconds.set_default();
        }
        self.usage_core_nano_seconds.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage_core_nano_seconds(&mut self) -> UInt64Value {
        self.usage_core_nano_seconds.take().unwrap_or_else(|| UInt64Value::new())
    }
}

impl ::protobuf::Message for CpuUsage {
    fn is_initialized(&self) -> bool {
        for v in &self.usage_core_nano_seconds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage_core_nano_seconds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.usage_core_nano_seconds.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if let Some(ref v) = self.usage_core_nano_seconds.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuUsage {
        CpuUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &CpuUsage| { &m.timestamp },
                |m: &mut CpuUsage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt64Value>>(
                "usage_core_nano_seconds",
                |m: &CpuUsage| { &m.usage_core_nano_seconds },
                |m: &mut CpuUsage| { &mut m.usage_core_nano_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CpuUsage>(
                "CpuUsage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CpuUsage {
        static instance: ::protobuf::rt::LazyV2<CpuUsage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CpuUsage::new)
    }
}

impl ::protobuf::Clear for CpuUsage {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.usage_core_nano_seconds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemoryUsage {
    // message fields
    pub timestamp: i64,
    pub working_set_bytes: ::protobuf::SingularPtrField<UInt64Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemoryUsage {
    fn default() -> &'a MemoryUsage {
        <MemoryUsage as ::protobuf::Message>::default_instance()
    }
}

impl MemoryUsage {
    pub fn new() -> MemoryUsage {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // .runtime.v1.UInt64Value working_set_bytes = 2;


    pub fn get_working_set_bytes(&self) -> &UInt64Value {
        self.working_set_bytes.as_ref().unwrap_or_else(|| <UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_working_set_bytes(&mut self) {
        self.working_set_bytes.clear();
    }

    pub fn has_working_set_bytes(&self) -> bool {
        self.working_set_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_working_set_bytes(&mut self, v: UInt64Value) {
        self.working_set_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_set_bytes(&mut self) -> &mut UInt64Value {
        if self.working_set_bytes.is_none() {
            self.working_set_bytes.set_default();
        }
        self.working_set_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_working_set_bytes(&mut self) -> UInt64Value {
        self.working_set_bytes.take().unwrap_or_else(|| UInt64Value::new())
    }
}

impl ::protobuf::Message for MemoryUsage {
    fn is_initialized(&self) -> bool {
        for v in &self.working_set_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.working_set_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.working_set_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if let Some(ref v) = self.working_set_bytes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemoryUsage {
        MemoryUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &MemoryUsage| { &m.timestamp },
                |m: &mut MemoryUsage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt64Value>>(
                "working_set_bytes",
                |m: &MemoryUsage| { &m.working_set_bytes },
                |m: &mut MemoryUsage| { &mut m.working_set_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemoryUsage>(
                "MemoryUsage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemoryUsage {
        static instance: ::protobuf::rt::LazyV2<MemoryUsage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemoryUsage::new)
    }
}

impl ::protobuf::Clear for MemoryUsage {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.working_set_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemoryUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReopenContainerLogRequest {
    // message fields
    pub container_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReopenContainerLogRequest {
    fn default() -> &'a ReopenContainerLogRequest {
        <ReopenContainerLogRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReopenContainerLogRequest {
    pub fn new() -> ReopenContainerLogRequest {
        ::std::default::Default::default()
    }

    // string container_id = 1;


    pub fn get_container_id(&self) -> &str {
        &self.container_id
    }
    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ::std::string::String) {
        self.container_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id(&mut self) -> &mut ::std::string::String {
        &mut self.container_id
    }

    // Take field
    pub fn take_container_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.container_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReopenContainerLogRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.container_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.container_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.container_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.container_id.is_empty() {
            os.write_string(1, &self.container_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReopenContainerLogRequest {
        ReopenContainerLogRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container_id",
                |m: &ReopenContainerLogRequest| { &m.container_id },
                |m: &mut ReopenContainerLogRequest| { &mut m.container_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReopenContainerLogRequest>(
                "ReopenContainerLogRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReopenContainerLogRequest {
        static instance: ::protobuf::rt::LazyV2<ReopenContainerLogRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReopenContainerLogRequest::new)
    }
}

impl ::protobuf::Clear for ReopenContainerLogRequest {
    fn clear(&mut self) {
        self.container_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReopenContainerLogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReopenContainerLogRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReopenContainerLogResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReopenContainerLogResponse {
    fn default() -> &'a ReopenContainerLogResponse {
        <ReopenContainerLogResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReopenContainerLogResponse {
    pub fn new() -> ReopenContainerLogResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReopenContainerLogResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReopenContainerLogResponse {
        ReopenContainerLogResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReopenContainerLogResponse>(
                "ReopenContainerLogResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReopenContainerLogResponse {
        static instance: ::protobuf::rt::LazyV2<ReopenContainerLogResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReopenContainerLogResponse::new)
    }
}

impl ::protobuf::Clear for ReopenContainerLogResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReopenContainerLogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReopenContainerLogResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Protocol {
    TCP = 0,
    UDP = 1,
    SCTP = 2,
}

impl ::protobuf::ProtobufEnum for Protocol {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Protocol> {
        match value {
            0 => ::std::option::Option::Some(Protocol::TCP),
            1 => ::std::option::Option::Some(Protocol::UDP),
            2 => ::std::option::Option::Some(Protocol::SCTP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Protocol] = &[
            Protocol::TCP,
            Protocol::UDP,
            Protocol::SCTP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Protocol>("Protocol", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Protocol {
}

impl ::std::default::Default for Protocol {
    fn default() -> Self {
        Protocol::TCP
    }
}

impl ::protobuf::reflect::ProtobufValue for Protocol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MountPropagation {
    PROPAGATION_PRIVATE = 0,
    PROPAGATION_HOST_TO_CONTAINER = 1,
    PROPAGATION_BIDIRECTIONAL = 2,
}

impl ::protobuf::ProtobufEnum for MountPropagation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MountPropagation> {
        match value {
            0 => ::std::option::Option::Some(MountPropagation::PROPAGATION_PRIVATE),
            1 => ::std::option::Option::Some(MountPropagation::PROPAGATION_HOST_TO_CONTAINER),
            2 => ::std::option::Option::Some(MountPropagation::PROPAGATION_BIDIRECTIONAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MountPropagation] = &[
            MountPropagation::PROPAGATION_PRIVATE,
            MountPropagation::PROPAGATION_HOST_TO_CONTAINER,
            MountPropagation::PROPAGATION_BIDIRECTIONAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MountPropagation>("MountPropagation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MountPropagation {
}

impl ::std::default::Default for MountPropagation {
    fn default() -> Self {
        MountPropagation::PROPAGATION_PRIVATE
    }
}

impl ::protobuf::reflect::ProtobufValue for MountPropagation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NamespaceMode {
    POD = 0,
    CONTAINER = 1,
    NODE = 2,
    TARGET = 3,
}

impl ::protobuf::ProtobufEnum for NamespaceMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NamespaceMode> {
        match value {
            0 => ::std::option::Option::Some(NamespaceMode::POD),
            1 => ::std::option::Option::Some(NamespaceMode::CONTAINER),
            2 => ::std::option::Option::Some(NamespaceMode::NODE),
            3 => ::std::option::Option::Some(NamespaceMode::TARGET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NamespaceMode] = &[
            NamespaceMode::POD,
            NamespaceMode::CONTAINER,
            NamespaceMode::NODE,
            NamespaceMode::TARGET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NamespaceMode>("NamespaceMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NamespaceMode {
}

impl ::std::default::Default for NamespaceMode {
    fn default() -> Self {
        NamespaceMode::POD
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PodSandboxState {
    SANDBOX_READY = 0,
    SANDBOX_NOTREADY = 1,
}

impl ::protobuf::ProtobufEnum for PodSandboxState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PodSandboxState> {
        match value {
            0 => ::std::option::Option::Some(PodSandboxState::SANDBOX_READY),
            1 => ::std::option::Option::Some(PodSandboxState::SANDBOX_NOTREADY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PodSandboxState] = &[
            PodSandboxState::SANDBOX_READY,
            PodSandboxState::SANDBOX_NOTREADY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PodSandboxState>("PodSandboxState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PodSandboxState {
}

impl ::std::default::Default for PodSandboxState {
    fn default() -> Self {
        PodSandboxState::SANDBOX_READY
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSandboxState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerState {
    CONTAINER_CREATED = 0,
    CONTAINER_RUNNING = 1,
    CONTAINER_EXITED = 2,
    CONTAINER_UNKNOWN = 3,
}

impl ::protobuf::ProtobufEnum for ContainerState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerState> {
        match value {
            0 => ::std::option::Option::Some(ContainerState::CONTAINER_CREATED),
            1 => ::std::option::Option::Some(ContainerState::CONTAINER_RUNNING),
            2 => ::std::option::Option::Some(ContainerState::CONTAINER_EXITED),
            3 => ::std::option::Option::Some(ContainerState::CONTAINER_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContainerState] = &[
            ContainerState::CONTAINER_CREATED,
            ContainerState::CONTAINER_RUNNING,
            ContainerState::CONTAINER_EXITED,
            ContainerState::CONTAINER_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContainerState>("ContainerState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContainerState {
}

impl ::std::default::Default for ContainerState {
    fn default() -> Self {
        ContainerState::CONTAINER_CREATED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x12\nruntime.v1\x1a-github.com/gogo/protobuf/gogoproto/gog\
    o.proto\"*\n\x0eVersionRequest\x12\x18\n\x07version\x18\x01\x20\x01(\tR\
    \x07version\"\xa7\x01\n\x0fVersionResponse\x12\x18\n\x07version\x18\x01\
    \x20\x01(\tR\x07version\x12!\n\x0cruntime_name\x18\x02\x20\x01(\tR\x0bru\
    ntimeName\x12'\n\x0fruntime_version\x18\x03\x20\x01(\tR\x0eruntimeVersio\
    n\x12.\n\x13runtime_api_version\x18\x04\x20\x01(\tR\x11runtimeApiVersion\
    \"[\n\tDNSConfig\x12\x18\n\x07servers\x18\x01\x20\x03(\tR\x07servers\x12\
    \x1a\n\x08searches\x18\x02\x20\x03(\tR\x08searches\x12\x18\n\x07options\
    \x18\x03\x20\x03(\tR\x07options\"\x9c\x01\n\x0bPortMapping\x120\n\x08pro\
    tocol\x18\x01\x20\x01(\x0e2\x14.runtime.v1.ProtocolR\x08protocol\x12%\n\
    \x0econtainer_port\x18\x02\x20\x01(\x05R\rcontainerPort\x12\x1b\n\thost_\
    port\x18\x03\x20\x01(\x05R\x08hostPort\x12\x17\n\x07host_ip\x18\x04\x20\
    \x01(\tR\x06hostIp\"\xd0\x01\n\x05Mount\x12%\n\x0econtainer_path\x18\x01\
    \x20\x01(\tR\rcontainerPath\x12\x1b\n\thost_path\x18\x02\x20\x01(\tR\x08\
    hostPath\x12\x1a\n\x08readonly\x18\x03\x20\x01(\x08R\x08readonly\x12'\n\
    \x0fselinux_relabel\x18\x04\x20\x01(\x08R\x0eselinuxRelabel\x12>\n\x0bpr\
    opagation\x18\x05\x20\x01(\x0e2\x1c.runtime.v1.MountPropagationR\x0bprop\
    agation\"\xbd\x01\n\x0fNamespaceOption\x123\n\x07network\x18\x01\x20\x01\
    (\x0e2\x19.runtime.v1.NamespaceModeR\x07network\x12+\n\x03pid\x18\x02\
    \x20\x01(\x0e2\x19.runtime.v1.NamespaceModeR\x03pid\x12+\n\x03ipc\x18\
    \x03\x20\x01(\x0e2\x19.runtime.v1.NamespaceModeR\x03ipc\x12\x1b\n\ttarge\
    t_id\x18\x04\x20\x01(\tR\x08targetId\"\"\n\nInt64Value\x12\x14\n\x05valu\
    e\x18\x01\x20\x01(\x03R\x05value\"\xbd\x04\n\x1bLinuxSandboxSecurityCont\
    ext\x12H\n\x11namespace_options\x18\x01\x20\x01(\x0b2\x1b.runtime.v1.Nam\
    espaceOptionR\x10namespaceOptions\x12B\n\x0fselinux_options\x18\x02\x20\
    \x01(\x0b2\x19.runtime.v1.SELinuxOptionR\x0eselinuxOptions\x126\n\x0brun\
    _as_user\x18\x03\x20\x01(\x0b2\x16.runtime.v1.Int64ValueR\trunAsUser\x12\
    8\n\x0crun_as_group\x18\x08\x20\x01(\x0b2\x16.runtime.v1.Int64ValueR\nru\
    nAsGroup\x12'\n\x0freadonly_rootfs\x18\x04\x20\x01(\x08R\x0ereadonlyRoot\
    fs\x12/\n\x13supplemental_groups\x18\x05\x20\x03(\x03R\x12supplementalGr\
    oups\x12\x1e\n\nprivileged\x18\x06\x20\x01(\x08R\nprivileged\x125\n\x07s\
    eccomp\x18\t\x20\x01(\x0b2\x1b.runtime.v1.SecurityProfileR\x07seccomp\
    \x127\n\x08apparmor\x18\n\x20\x01(\x0b2\x1b.runtime.v1.SecurityProfileR\
    \x08apparmor\x124\n\x14seccomp_profile_path\x18\x07\x20\x01(\tR\x12secco\
    mpProfilePathB\x02\x18\x01\"\xc4\x01\n\x0fSecurityProfile\x12J\n\x0cprof\
    ile_type\x18\x01\x20\x01(\x0e2'.runtime.v1.SecurityProfile.ProfileTypeR\
    \x0bprofileType\x12#\n\rlocalhost_ref\x18\x02\x20\x01(\tR\x0clocalhostRe\
    f\"@\n\x0bProfileType\x12\x12\n\x0eRuntimeDefault\x10\0\x12\x0e\n\nUncon\
    fined\x10\x01\x12\r\n\tLocalhost\x10\x02\"\x96\x02\n\x15LinuxPodSandboxC\
    onfig\x12#\n\rcgroup_parent\x18\x01\x20\x01(\tR\x0ccgroupParent\x12R\n\
    \x10security_context\x18\x02\x20\x01(\x0b2'.runtime.v1.LinuxSandboxSecur\
    ityContextR\x0fsecurityContext\x12H\n\x07sysctls\x18\x03\x20\x03(\x0b2..\
    runtime.v1.LinuxPodSandboxConfig.SysctlsEntryR\x07sysctls\x1a:\n\x0cSysc\
    tlsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"r\n\x12PodSandboxMetadata\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03uid\x18\x02\x20\
    \x01(\tR\x03uid\x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12\
    \x18\n\x07attempt\x18\x04\x20\x01(\rR\x07attempt\"\xca\x04\n\x10PodSandb\
    oxConfig\x12:\n\x08metadata\x18\x01\x20\x01(\x0b2\x1e.runtime.v1.PodSand\
    boxMetadataR\x08metadata\x12\x1a\n\x08hostname\x18\x02\x20\x01(\tR\x08ho\
    stname\x12#\n\rlog_directory\x18\x03\x20\x01(\tR\x0clogDirectory\x124\n\
    \ndns_config\x18\x04\x20\x01(\x0b2\x15.runtime.v1.DNSConfigR\tdnsConfig\
    \x12<\n\rport_mappings\x18\x05\x20\x03(\x0b2\x17.runtime.v1.PortMappingR\
    \x0cportMappings\x12@\n\x06labels\x18\x06\x20\x03(\x0b2(.runtime.v1.PodS\
    andboxConfig.LabelsEntryR\x06labels\x12O\n\x0bannotations\x18\x07\x20\
    \x03(\x0b2-.runtime.v1.PodSandboxConfig.AnnotationsEntryR\x0bannotations\
    \x127\n\x05linux\x18\x08\x20\x01(\x0b2!.runtime.v1.LinuxPodSandboxConfig\
    R\x05linux\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\
    \x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"u\n\x14RunPodSandbox\
    Request\x124\n\x06config\x18\x01\x20\x01(\x0b2\x1c.runtime.v1.PodSandbox\
    ConfigR\x06config\x12'\n\x0fruntime_handler\x18\x02\x20\x01(\tR\x0erunti\
    meHandler\"=\n\x15RunPodSandboxResponse\x12$\n\x0epod_sandbox_id\x18\x01\
    \x20\x01(\tR\x0cpodSandboxId\"=\n\x15StopPodSandboxRequest\x12$\n\x0epod\
    _sandbox_id\x18\x01\x20\x01(\tR\x0cpodSandboxId\"\x18\n\x16StopPodSandbo\
    xResponse\"?\n\x17RemovePodSandboxRequest\x12$\n\x0epod_sandbox_id\x18\
    \x01\x20\x01(\tR\x0cpodSandboxId\"\x1a\n\x18RemovePodSandboxResponse\"Y\
    \n\x17PodSandboxStatusRequest\x12$\n\x0epod_sandbox_id\x18\x01\x20\x01(\
    \tR\x0cpodSandboxId\x12\x18\n\x07verbose\x18\x02\x20\x01(\x08R\x07verbos\
    e\"\x17\n\x05PodIP\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\"c\n\x17Pod\
    SandboxNetworkStatus\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x128\n\
    \x0eadditional_ips\x18\x02\x20\x03(\x0b2\x11.runtime.v1.PodIPR\raddition\
    alIps\"B\n\tNamespace\x125\n\x07options\x18\x02\x20\x01(\x0b2\x1b.runtim\
    e.v1.NamespaceOptionR\x07options\"N\n\x15LinuxPodSandboxStatus\x125\n\nn\
    amespaces\x18\x01\x20\x01(\x0b2\x15.runtime.v1.NamespaceR\nnamespaces\"\
    \xdf\x04\n\x10PodSandboxStatus\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12:\n\x08metadata\x18\x02\x20\x01(\x0b2\x1e.runtime.v1.PodSandboxMetad\
    ataR\x08metadata\x121\n\x05state\x18\x03\x20\x01(\x0e2\x1b.runtime.v1.Po\
    dSandboxStateR\x05state\x12\x1d\n\ncreated_at\x18\x04\x20\x01(\x03R\tcre\
    atedAt\x12=\n\x07network\x18\x05\x20\x01(\x0b2#.runtime.v1.PodSandboxNet\
    workStatusR\x07network\x127\n\x05linux\x18\x06\x20\x01(\x0b2!.runtime.v1\
    .LinuxPodSandboxStatusR\x05linux\x12@\n\x06labels\x18\x07\x20\x03(\x0b2(\
    .runtime.v1.PodSandboxStatus.LabelsEntryR\x06labels\x12O\n\x0bannotation\
    s\x18\x08\x20\x03(\x0b2-.runtime.v1.PodSandboxStatus.AnnotationsEntryR\
    \x0bannotations\x12'\n\x0fruntime_handler\x18\t\x20\x01(\tR\x0eruntimeHa\
    ndler\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10Ann\
    otationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xcd\x01\n\x18PodSandboxSta\
    tusResponse\x124\n\x06status\x18\x01\x20\x01(\x0b2\x1c.runtime.v1.PodSan\
    dboxStatusR\x06status\x12B\n\x04info\x18\x02\x20\x03(\x0b2..runtime.v1.P\
    odSandboxStatusResponse.InfoEntryR\x04info\x1a7\n\tInfoEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"I\n\x14PodSandboxStateValue\x121\n\x05state\x18\
    \x01\x20\x01(\x0e2\x1b.runtime.v1.PodSandboxStateR\x05state\"\xf4\x01\n\
    \x10PodSandboxFilter\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x126\n\
    \x05state\x18\x02\x20\x01(\x0b2\x20.runtime.v1.PodSandboxStateValueR\x05\
    state\x12V\n\x0elabel_selector\x18\x03\x20\x03(\x0b2/.runtime.v1.PodSand\
    boxFilter.LabelSelectorEntryR\rlabelSelector\x1a@\n\x12LabelSelectorEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"M\n\x15ListPodSandboxRequest\x124\n\x06\
    filter\x18\x01\x20\x01(\x0b2\x1c.runtime.v1.PodSandboxFilterR\x06filter\
    \"\xd5\x03\n\nPodSandbox\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12:\
    \n\x08metadata\x18\x02\x20\x01(\x0b2\x1e.runtime.v1.PodSandboxMetadataR\
    \x08metadata\x121\n\x05state\x18\x03\x20\x01(\x0e2\x1b.runtime.v1.PodSan\
    dboxStateR\x05state\x12\x1d\n\ncreated_at\x18\x04\x20\x01(\x03R\tcreated\
    At\x12:\n\x06labels\x18\x05\x20\x03(\x0b2\".runtime.v1.PodSandbox.Labels\
    EntryR\x06labels\x12I\n\x0bannotations\x18\x06\x20\x03(\x0b2'.runtime.v1\
    .PodSandbox.AnnotationsEntryR\x0bannotations\x12'\n\x0fruntime_handler\
    \x18\x07\x20\x01(\tR\x0eruntimeHandler\x1a9\n\x0bLabelsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a>\n\x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"F\n\x16ListPodSandboxResponse\x12,\n\x05items\x18\x01\x20\x03(\
    \x0b2\x16.runtime.v1.PodSandboxR\x05items\"\xab\x01\n\tImageSpec\x12\x14\
    \n\x05image\x18\x01\x20\x01(\tR\x05image\x12H\n\x0bannotations\x18\x02\
    \x20\x03(\x0b2&.runtime.v1.ImageSpec.AnnotationsEntryR\x0bannotations\
    \x1a>\n\x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"2\n\x08KeyVa\
    lue\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\"\xd1\x02\n\x17LinuxContainerResources\x12\x1d\
    \n\ncpu_period\x18\x01\x20\x01(\x03R\tcpuPeriod\x12\x1b\n\tcpu_quota\x18\
    \x02\x20\x01(\x03R\x08cpuQuota\x12\x1d\n\ncpu_shares\x18\x03\x20\x01(\
    \x03R\tcpuShares\x121\n\x15memory_limit_in_bytes\x18\x04\x20\x01(\x03R\
    \x12memoryLimitInBytes\x12\"\n\room_score_adj\x18\x05\x20\x01(\x03R\x0bo\
    omScoreAdj\x12\x1f\n\x0bcpuset_cpus\x18\x06\x20\x01(\tR\ncpusetCpus\x12\
    \x1f\n\x0bcpuset_mems\x18\x07\x20\x01(\tR\ncpusetMems\x12B\n\x0fhugepage\
    _limits\x18\x08\x20\x03(\x0b2\x19.runtime.v1.HugepageLimitR\x0ehugepageL\
    imits\"B\n\rHugepageLimit\x12\x1b\n\tpage_size\x18\x01\x20\x01(\tR\x08pa\
    geSize\x12\x14\n\x05limit\x18\x02\x20\x01(\x04R\x05limit\"a\n\rSELinuxOp\
    tion\x12\x12\n\x04user\x18\x01\x20\x01(\tR\x04user\x12\x12\n\x04role\x18\
    \x02\x20\x01(\tR\x04role\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\
    \x12\x14\n\x05level\x18\x04\x20\x01(\tR\x05level\"d\n\nCapability\x12)\n\
    \x10add_capabilities\x18\x01\x20\x03(\tR\x0faddCapabilities\x12+\n\x11dr\
    op_capabilities\x18\x02\x20\x03(\tR\x10dropCapabilities\"\xbe\x06\n\x1dL\
    inuxContainerSecurityContext\x12:\n\x0ccapabilities\x18\x01\x20\x01(\x0b\
    2\x16.runtime.v1.CapabilityR\x0ccapabilities\x12\x1e\n\nprivileged\x18\
    \x02\x20\x01(\x08R\nprivileged\x12H\n\x11namespace_options\x18\x03\x20\
    \x01(\x0b2\x1b.runtime.v1.NamespaceOptionR\x10namespaceOptions\x12B\n\
    \x0fselinux_options\x18\x04\x20\x01(\x0b2\x19.runtime.v1.SELinuxOptionR\
    \x0eselinuxOptions\x126\n\x0brun_as_user\x18\x05\x20\x01(\x0b2\x16.runti\
    me.v1.Int64ValueR\trunAsUser\x128\n\x0crun_as_group\x18\x0c\x20\x01(\x0b\
    2\x16.runtime.v1.Int64ValueR\nrunAsGroup\x12&\n\x0frun_as_username\x18\
    \x06\x20\x01(\tR\rrunAsUsername\x12'\n\x0freadonly_rootfs\x18\x07\x20\
    \x01(\x08R\x0ereadonlyRootfs\x12/\n\x13supplemental_groups\x18\x08\x20\
    \x03(\x03R\x12supplementalGroups\x12\x20\n\x0cno_new_privs\x18\x0b\x20\
    \x01(\x08R\nnoNewPrivs\x12!\n\x0cmasked_paths\x18\r\x20\x03(\tR\x0bmaske\
    dPaths\x12%\n\x0ereadonly_paths\x18\x0e\x20\x03(\tR\rreadonlyPaths\x125\
    \n\x07seccomp\x18\x0f\x20\x01(\x0b2\x1b.runtime.v1.SecurityProfileR\x07s\
    eccomp\x127\n\x08apparmor\x18\x10\x20\x01(\x0b2\x1b.runtime.v1.SecurityP\
    rofileR\x08apparmor\x12-\n\x10apparmor_profile\x18\t\x20\x01(\tR\x0fappa\
    rmorProfileB\x02\x18\x01\x124\n\x14seccomp_profile_path\x18\n\x20\x01(\t\
    R\x12seccompProfilePathB\x02\x18\x01\"\xaf\x01\n\x14LinuxContainerConfig\
    \x12A\n\tresources\x18\x01\x20\x01(\x0b2#.runtime.v1.LinuxContainerResou\
    rcesR\tresources\x12T\n\x10security_context\x18\x02\x20\x01(\x0b2).runti\
    me.v1.LinuxContainerSecurityContextR\x0fsecurityContext\"r\n\x1fWindowsC\
    ontainerSecurityContext\x12&\n\x0frun_as_username\x18\x01\x20\x01(\tR\rr\
    unAsUsername\x12'\n\x0fcredential_spec\x18\x02\x20\x01(\tR\x0ecredential\
    Spec\"\xb5\x01\n\x16WindowsContainerConfig\x12C\n\tresources\x18\x01\x20\
    \x01(\x0b2%.runtime.v1.WindowsContainerResourcesR\tresources\x12V\n\x10s\
    ecurity_context\x18\x02\x20\x01(\x0b2+.runtime.v1.WindowsContainerSecuri\
    tyContextR\x0fsecurityContext\"\xab\x01\n\x19WindowsContainerResources\
    \x12\x1d\n\ncpu_shares\x18\x01\x20\x01(\x03R\tcpuShares\x12\x1b\n\tcpu_c\
    ount\x18\x02\x20\x01(\x03R\x08cpuCount\x12\x1f\n\x0bcpu_maximum\x18\x03\
    \x20\x01(\x03R\ncpuMaximum\x121\n\x15memory_limit_in_bytes\x18\x04\x20\
    \x01(\x03R\x12memoryLimitInBytes\"A\n\x11ContainerMetadata\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07attempt\x18\x02\x20\x01(\r\
    R\x07attempt\"n\n\x06Device\x12%\n\x0econtainer_path\x18\x01\x20\x01(\tR\
    \rcontainerPath\x12\x1b\n\thost_path\x18\x02\x20\x01(\tR\x08hostPath\x12\
    \x20\n\x0bpermissions\x18\x03\x20\x01(\tR\x0bpermissions\"\xaf\x06\n\x0f\
    ContainerConfig\x129\n\x08metadata\x18\x01\x20\x01(\x0b2\x1d.runtime.v1.\
    ContainerMetadataR\x08metadata\x12+\n\x05image\x18\x02\x20\x01(\x0b2\x15\
    .runtime.v1.ImageSpecR\x05image\x12\x18\n\x07command\x18\x03\x20\x03(\tR\
    \x07command\x12\x12\n\x04args\x18\x04\x20\x03(\tR\x04args\x12\x1f\n\x0bw\
    orking_dir\x18\x05\x20\x01(\tR\nworkingDir\x12(\n\x04envs\x18\x06\x20\
    \x03(\x0b2\x14.runtime.v1.KeyValueR\x04envs\x12)\n\x06mounts\x18\x07\x20\
    \x03(\x0b2\x11.runtime.v1.MountR\x06mounts\x12,\n\x07devices\x18\x08\x20\
    \x03(\x0b2\x12.runtime.v1.DeviceR\x07devices\x12?\n\x06labels\x18\t\x20\
    \x03(\x0b2'.runtime.v1.ContainerConfig.LabelsEntryR\x06labels\x12N\n\x0b\
    annotations\x18\n\x20\x03(\x0b2,.runtime.v1.ContainerConfig.AnnotationsE\
    ntryR\x0bannotations\x12\x19\n\x08log_path\x18\x0b\x20\x01(\tR\x07logPat\
    h\x12\x14\n\x05stdin\x18\x0c\x20\x01(\x08R\x05stdin\x12\x1d\n\nstdin_onc\
    e\x18\r\x20\x01(\x08R\tstdinOnce\x12\x10\n\x03tty\x18\x0e\x20\x01(\x08R\
    \x03tty\x126\n\x05linux\x18\x0f\x20\x01(\x0b2\x20.runtime.v1.LinuxContai\
    nerConfigR\x05linux\x12<\n\x07windows\x18\x10\x20\x01(\x0b2\".runtime.v1\
    .WindowsContainerConfigR\x07windows\x1a9\n\x0bLabelsEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\x1a>\n\x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\xb8\x01\n\x16CreateContainerRequest\x12$\n\x0epod_sandbox_id\x18\
    \x01\x20\x01(\tR\x0cpodSandboxId\x123\n\x06config\x18\x02\x20\x01(\x0b2\
    \x1b.runtime.v1.ContainerConfigR\x06config\x12C\n\x0esandbox_config\x18\
    \x03\x20\x01(\x0b2\x1c.runtime.v1.PodSandboxConfigR\rsandboxConfig\"<\n\
    \x17CreateContainerResponse\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\
    \x0bcontainerId\":\n\x15StartContainerRequest\x12!\n\x0ccontainer_id\x18\
    \x01\x20\x01(\tR\x0bcontainerId\"\x18\n\x16StartContainerResponse\"S\n\
    \x14StopContainerRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bc\
    ontainerId\x12\x18\n\x07timeout\x18\x02\x20\x01(\x03R\x07timeout\"\x17\n\
    \x15StopContainerResponse\";\n\x16RemoveContainerRequest\x12!\n\x0cconta\
    iner_id\x18\x01\x20\x01(\tR\x0bcontainerId\"\x19\n\x17RemoveContainerRes\
    ponse\"G\n\x13ContainerStateValue\x120\n\x05state\x18\x01\x20\x01(\x0e2\
    \x1a.runtime.v1.ContainerStateR\x05state\"\x97\x02\n\x0fContainerFilter\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x125\n\x05state\x18\x02\x20\
    \x01(\x0b2\x1f.runtime.v1.ContainerStateValueR\x05state\x12$\n\x0epod_sa\
    ndbox_id\x18\x03\x20\x01(\tR\x0cpodSandboxId\x12U\n\x0elabel_selector\
    \x18\x04\x20\x03(\x0b2..runtime.v1.ContainerFilter.LabelSelectorEntryR\r\
    labelSelector\x1a@\n\x12LabelSelectorEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"L\n\x15ListContainersRequest\x123\n\x06filter\x18\x01\x20\x01(\x0b\
    2\x1b.runtime.v1.ContainerFilterR\x06filter\"\x97\x04\n\tContainer\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12$\n\x0epod_sandbox_id\x18\x02\
    \x20\x01(\tR\x0cpodSandboxId\x129\n\x08metadata\x18\x03\x20\x01(\x0b2\
    \x1d.runtime.v1.ContainerMetadataR\x08metadata\x12+\n\x05image\x18\x04\
    \x20\x01(\x0b2\x15.runtime.v1.ImageSpecR\x05image\x12\x1b\n\timage_ref\
    \x18\x05\x20\x01(\tR\x08imageRef\x120\n\x05state\x18\x06\x20\x01(\x0e2\
    \x1a.runtime.v1.ContainerStateR\x05state\x12\x1d\n\ncreated_at\x18\x07\
    \x20\x01(\x03R\tcreatedAt\x129\n\x06labels\x18\x08\x20\x03(\x0b2!.runtim\
    e.v1.Container.LabelsEntryR\x06labels\x12H\n\x0bannotations\x18\t\x20\
    \x03(\x0b2&.runtime.v1.Container.AnnotationsEntryR\x0bannotations\x1a9\n\
    \x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10AnnotationsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"O\n\x16ListContainersResponse\x125\
    \n\ncontainers\x18\x01\x20\x03(\x0b2\x15.runtime.v1.ContainerR\ncontaine\
    rs\"U\n\x16ContainerStatusRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01\
    (\tR\x0bcontainerId\x12\x18\n\x07verbose\x18\x02\x20\x01(\x08R\x07verbos\
    e\"\xd8\x05\n\x0fContainerStatus\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x129\n\x08metadata\x18\x02\x20\x01(\x0b2\x1d.runtime.v1.ContainerMeta\
    dataR\x08metadata\x120\n\x05state\x18\x03\x20\x01(\x0e2\x1a.runtime.v1.C\
    ontainerStateR\x05state\x12\x1d\n\ncreated_at\x18\x04\x20\x01(\x03R\tcre\
    atedAt\x12\x1d\n\nstarted_at\x18\x05\x20\x01(\x03R\tstartedAt\x12\x1f\n\
    \x0bfinished_at\x18\x06\x20\x01(\x03R\nfinishedAt\x12\x1b\n\texit_code\
    \x18\x07\x20\x01(\x05R\x08exitCode\x12+\n\x05image\x18\x08\x20\x01(\x0b2\
    \x15.runtime.v1.ImageSpecR\x05image\x12\x1b\n\timage_ref\x18\t\x20\x01(\
    \tR\x08imageRef\x12\x16\n\x06reason\x18\n\x20\x01(\tR\x06reason\x12\x18\
    \n\x07message\x18\x0b\x20\x01(\tR\x07message\x12?\n\x06labels\x18\x0c\
    \x20\x03(\x0b2'.runtime.v1.ContainerStatus.LabelsEntryR\x06labels\x12N\n\
    \x0bannotations\x18\r\x20\x03(\x0b2,.runtime.v1.ContainerStatus.Annotati\
    onsEntryR\x0bannotations\x12)\n\x06mounts\x18\x0e\x20\x03(\x0b2\x11.runt\
    ime.v1.MountR\x06mounts\x12\x19\n\x08log_path\x18\x0f\x20\x01(\tR\x07log\
    Path\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10Ann\
    otationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xca\x01\n\x17ContainerStat\
    usResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.runtime.v1.Contain\
    erStatusR\x06status\x12A\n\x04info\x18\x02\x20\x03(\x0b2-.runtime.v1.Con\
    tainerStatusResponse.InfoEntryR\x04info\x1a7\n\tInfoEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\"\xe0\x02\n\x1fUpdateContainerResourcesRequest\x12!\n\
    \x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcontainerId\x129\n\x05linux\x18\
    \x02\x20\x01(\x0b2#.runtime.v1.LinuxContainerResourcesR\x05linux\x12?\n\
    \x07windows\x18\x03\x20\x01(\x0b2%.runtime.v1.WindowsContainerResourcesR\
    \x07windows\x12^\n\x0bannotations\x18\x04\x20\x03(\x0b2<.runtime.v1.Upda\
    teContainerResourcesRequest.AnnotationsEntryR\x0bannotations\x1a>\n\x10A\
    nnotationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\"\n\x20UpdateContaine\
    rResourcesResponse\"`\n\x0fExecSyncRequest\x12!\n\x0ccontainer_id\x18\
    \x01\x20\x01(\tR\x0bcontainerId\x12\x10\n\x03cmd\x18\x02\x20\x03(\tR\x03\
    cmd\x12\x18\n\x07timeout\x18\x03\x20\x01(\x03R\x07timeout\"_\n\x10ExecSy\
    ncResponse\x12\x16\n\x06stdout\x18\x01\x20\x01(\x0cR\x06stdout\x12\x16\n\
    \x06stderr\x18\x02\x20\x01(\x0cR\x06stderr\x12\x1b\n\texit_code\x18\x03\
    \x20\x01(\x05R\x08exitCode\"\x9a\x01\n\x0bExecRequest\x12!\n\x0ccontaine\
    r_id\x18\x01\x20\x01(\tR\x0bcontainerId\x12\x10\n\x03cmd\x18\x02\x20\x03\
    (\tR\x03cmd\x12\x10\n\x03tty\x18\x03\x20\x01(\x08R\x03tty\x12\x14\n\x05s\
    tdin\x18\x04\x20\x01(\x08R\x05stdin\x12\x16\n\x06stdout\x18\x05\x20\x01(\
    \x08R\x06stdout\x12\x16\n\x06stderr\x18\x06\x20\x01(\x08R\x06stderr\"\
    \x20\n\x0cExecResponse\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\"\x8a\
    \x01\n\rAttachRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\tR\x0bcont\
    ainerId\x12\x14\n\x05stdin\x18\x02\x20\x01(\x08R\x05stdin\x12\x10\n\x03t\
    ty\x18\x03\x20\x01(\x08R\x03tty\x12\x16\n\x06stdout\x18\x04\x20\x01(\x08\
    R\x06stdout\x12\x16\n\x06stderr\x18\x05\x20\x01(\x08R\x06stderr\"\"\n\
    \x0eAttachResponse\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\"N\n\x12P\
    ortForwardRequest\x12$\n\x0epod_sandbox_id\x18\x01\x20\x01(\tR\x0cpodSan\
    dboxId\x12\x12\n\x04port\x18\x02\x20\x03(\x05R\x04port\"'\n\x13PortForwa\
    rdResponse\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\":\n\x0bImageFilt\
    er\x12+\n\x05image\x18\x01\x20\x01(\x0b2\x15.runtime.v1.ImageSpecR\x05im\
    age\"D\n\x11ListImagesRequest\x12/\n\x06filter\x18\x01\x20\x01(\x0b2\x17\
    .runtime.v1.ImageFilterR\x06filter\"\xdc\x01\n\x05Image\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1b\n\trepo_tags\x18\x02\x20\x03(\tR\x08r\
    epoTags\x12!\n\x0crepo_digests\x18\x03\x20\x03(\tR\x0brepoDigests\x12\
    \x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\x12(\n\x03uid\x18\x05\x20\
    \x01(\x0b2\x16.runtime.v1.Int64ValueR\x03uid\x12\x1a\n\x08username\x18\
    \x06\x20\x01(\tR\x08username\x12)\n\x04spec\x18\x07\x20\x01(\x0b2\x15.ru\
    ntime.v1.ImageSpecR\x04spec\"?\n\x12ListImagesResponse\x12)\n\x06images\
    \x18\x01\x20\x03(\x0b2\x11.runtime.v1.ImageR\x06images\"[\n\x12ImageStat\
    usRequest\x12+\n\x05image\x18\x01\x20\x01(\x0b2\x15.runtime.v1.ImageSpec\
    R\x05image\x12\x18\n\x07verbose\x18\x02\x20\x01(\x08R\x07verbose\"\xb6\
    \x01\n\x13ImageStatusResponse\x12'\n\x05image\x18\x01\x20\x01(\x0b2\x11.\
    runtime.v1.ImageR\x05image\x12=\n\x04info\x18\x02\x20\x03(\x0b2).runtime\
    .v1.ImageStatusResponse.InfoEntryR\x04info\x1a7\n\tInfoEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\xcd\x01\n\nAuthConfig\x12\x1a\n\x08username\x18\
    \x01\x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\
    \x08password\x12\x12\n\x04auth\x18\x03\x20\x01(\tR\x04auth\x12%\n\x0eser\
    ver_address\x18\x04\x20\x01(\tR\rserverAddress\x12%\n\x0eidentity_token\
    \x18\x05\x20\x01(\tR\ridentityToken\x12%\n\x0eregistry_token\x18\x06\x20\
    \x01(\tR\rregistryToken\"\xb0\x01\n\x10PullImageRequest\x12+\n\x05image\
    \x18\x01\x20\x01(\x0b2\x15.runtime.v1.ImageSpecR\x05image\x12*\n\x04auth\
    \x18\x02\x20\x01(\x0b2\x16.runtime.v1.AuthConfigR\x04auth\x12C\n\x0esand\
    box_config\x18\x03\x20\x01(\x0b2\x1c.runtime.v1.PodSandboxConfigR\rsandb\
    oxConfig\"0\n\x11PullImageResponse\x12\x1b\n\timage_ref\x18\x01\x20\x01(\
    \tR\x08imageRef\"A\n\x12RemoveImageRequest\x12+\n\x05image\x18\x01\x20\
    \x01(\x0b2\x15.runtime.v1.ImageSpecR\x05image\"\x15\n\x13RemoveImageResp\
    onse\"*\n\rNetworkConfig\x12\x19\n\x08pod_cidr\x18\x01\x20\x01(\tR\x07po\
    dCidr\"Q\n\rRuntimeConfig\x12@\n\x0enetwork_config\x18\x01\x20\x01(\x0b2\
    \x19.runtime.v1.NetworkConfigR\rnetworkConfig\"^\n\x1aUpdateRuntimeConfi\
    gRequest\x12@\n\x0eruntime_config\x18\x01\x20\x01(\x0b2\x19.runtime.v1.R\
    untimeConfigR\rruntimeConfig\"\x1d\n\x1bUpdateRuntimeConfigResponse\"p\n\
    \x10RuntimeCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x16\n\x06status\x18\x02\x20\x01(\x08R\x06status\x12\x16\n\x06reason\x18\
    \x03\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07m\
    essage\"M\n\rRuntimeStatus\x12<\n\nconditions\x18\x01\x20\x03(\x0b2\x1c.\
    runtime.v1.RuntimeConditionR\nconditions\")\n\rStatusRequest\x12\x18\n\
    \x07verbose\x18\x01\x20\x01(\x08R\x07verbose\"\xb6\x01\n\x0eStatusRespon\
    se\x121\n\x06status\x18\x01\x20\x01(\x0b2\x19.runtime.v1.RuntimeStatusR\
    \x06status\x128\n\x04info\x18\x02\x20\x03(\x0b2$.runtime.v1.StatusRespon\
    se.InfoEntryR\x04info\x1a7\n\tInfoEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\
    \x14\n\x12ImageFsInfoRequest\"#\n\x0bUInt64Value\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x04R\x05value\"6\n\x14FilesystemIdentifier\x12\x1e\n\nmoun\
    tpoint\x18\x01\x20\x01(\tR\nmountpoint\"\xd8\x01\n\x0fFilesystemUsage\
    \x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimestamp\x125\n\x05fs_id\
    \x18\x02\x20\x01(\x0b2\x20.runtime.v1.FilesystemIdentifierR\x04fsId\x126\
    \n\nused_bytes\x18\x03\x20\x01(\x0b2\x17.runtime.v1.UInt64ValueR\tusedBy\
    tes\x128\n\x0binodes_used\x18\x04\x20\x01(\x0b2\x17.runtime.v1.UInt64Val\
    ueR\ninodesUsed\"_\n\x13ImageFsInfoResponse\x12H\n\x11image_filesystems\
    \x18\x01\x20\x03(\x0b2\x1b.runtime.v1.FilesystemUsageR\x10imageFilesyste\
    ms\":\n\x15ContainerStatsRequest\x12!\n\x0ccontainer_id\x18\x01\x20\x01(\
    \tR\x0bcontainerId\"J\n\x16ContainerStatsResponse\x120\n\x05stats\x18\
    \x01\x20\x01(\x0b2\x1a.runtime.v1.ContainerStatsR\x05stats\"U\n\x19ListC\
    ontainerStatsRequest\x128\n\x06filter\x18\x01\x20\x01(\x0b2\x20.runtime.\
    v1.ContainerStatsFilterR\x06filter\"\xea\x01\n\x14ContainerStatsFilter\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12$\n\x0epod_sandbox_id\x18\
    \x02\x20\x01(\tR\x0cpodSandboxId\x12Z\n\x0elabel_selector\x18\x03\x20\
    \x03(\x0b23.runtime.v1.ContainerStatsFilter.LabelSelectorEntryR\rlabelSe\
    lector\x1a@\n\x12LabelSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"N\n\
    \x1aListContainerStatsResponse\x120\n\x05stats\x18\x01\x20\x03(\x0b2\x1a\
    .runtime.v1.ContainerStatsR\x05stats\"\xf4\x02\n\x13ContainerAttributes\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\x08metadata\x18\x02\
    \x20\x01(\x0b2\x1d.runtime.v1.ContainerMetadataR\x08metadata\x12C\n\x06l\
    abels\x18\x03\x20\x03(\x0b2+.runtime.v1.ContainerAttributes.LabelsEntryR\
    \x06labels\x12R\n\x0bannotations\x18\x04\x20\x03(\x0b20.runtime.v1.Conta\
    inerAttributes.AnnotationsEntryR\x0bannotations\x1a9\n\x0bLabelsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10AnnotationsEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01\"\xee\x01\n\x0eContainerStats\x12?\n\nattributes\x18\
    \x01\x20\x01(\x0b2\x1f.runtime.v1.ContainerAttributesR\nattributes\x12&\
    \n\x03cpu\x18\x02\x20\x01(\x0b2\x14.runtime.v1.CpuUsageR\x03cpu\x12/\n\
    \x06memory\x18\x03\x20\x01(\x0b2\x17.runtime.v1.MemoryUsageR\x06memory\
    \x12B\n\x0ewritable_layer\x18\x04\x20\x01(\x0b2\x1b.runtime.v1.Filesyste\
    mUsageR\rwritableLayer\"x\n\x08CpuUsage\x12\x1c\n\ttimestamp\x18\x01\x20\
    \x01(\x03R\ttimestamp\x12N\n\x17usage_core_nano_seconds\x18\x02\x20\x01(\
    \x0b2\x17.runtime.v1.UInt64ValueR\x14usageCoreNanoSeconds\"p\n\x0bMemory\
    Usage\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimestamp\x12C\n\x11wo\
    rking_set_bytes\x18\x02\x20\x01(\x0b2\x17.runtime.v1.UInt64ValueR\x0fwor\
    kingSetBytes\">\n\x19ReopenContainerLogRequest\x12!\n\x0ccontainer_id\
    \x18\x01\x20\x01(\tR\x0bcontainerId\"\x1c\n\x1aReopenContainerLogRespons\
    e*&\n\x08Protocol\x12\x07\n\x03TCP\x10\0\x12\x07\n\x03UDP\x10\x01\x12\
    \x08\n\x04SCTP\x10\x02*m\n\x10MountPropagation\x12\x17\n\x13PROPAGATION_\
    PRIVATE\x10\0\x12!\n\x1dPROPAGATION_HOST_TO_CONTAINER\x10\x01\x12\x1d\n\
    \x19PROPAGATION_BIDIRECTIONAL\x10\x02*=\n\rNamespaceMode\x12\x07\n\x03PO\
    D\x10\0\x12\r\n\tCONTAINER\x10\x01\x12\x08\n\x04NODE\x10\x02\x12\n\n\x06\
    TARGET\x10\x03*:\n\x0fPodSandboxState\x12\x11\n\rSANDBOX_READY\x10\0\x12\
    \x14\n\x10SANDBOX_NOTREADY\x10\x01*k\n\x0eContainerState\x12\x15\n\x11CO\
    NTAINER_CREATED\x10\0\x12\x15\n\x11CONTAINER_RUNNING\x10\x01\x12\x14\n\
    \x10CONTAINER_EXITED\x10\x02\x12\x15\n\x11CONTAINER_UNKNOWN\x10\x032\xb8\
    \x0f\n\x0eRuntimeService\x12D\n\x07Version\x12\x1a.runtime.v1.VersionReq\
    uest\x1a\x1b.runtime.v1.VersionResponse\"\0\x12V\n\rRunPodSandbox\x12\
    \x20.runtime.v1.RunPodSandboxRequest\x1a!.runtime.v1.RunPodSandboxRespon\
    se\"\0\x12Y\n\x0eStopPodSandbox\x12!.runtime.v1.StopPodSandboxRequest\
    \x1a\".runtime.v1.StopPodSandboxResponse\"\0\x12_\n\x10RemovePodSandbox\
    \x12#.runtime.v1.RemovePodSandboxRequest\x1a$.runtime.v1.RemovePodSandbo\
    xResponse\"\0\x12_\n\x10PodSandboxStatus\x12#.runtime.v1.PodSandboxStatu\
    sRequest\x1a$.runtime.v1.PodSandboxStatusResponse\"\0\x12Y\n\x0eListPodS\
    andbox\x12!.runtime.v1.ListPodSandboxRequest\x1a\".runtime.v1.ListPodSan\
    dboxResponse\"\0\x12\\\n\x0fCreateContainer\x12\".runtime.v1.CreateConta\
    inerRequest\x1a#.runtime.v1.CreateContainerResponse\"\0\x12Y\n\x0eStartC\
    ontainer\x12!.runtime.v1.StartContainerRequest\x1a\".runtime.v1.StartCon\
    tainerResponse\"\0\x12V\n\rStopContainer\x12\x20.runtime.v1.StopContaine\
    rRequest\x1a!.runtime.v1.StopContainerResponse\"\0\x12\\\n\x0fRemoveCont\
    ainer\x12\".runtime.v1.RemoveContainerRequest\x1a#.runtime.v1.RemoveCont\
    ainerResponse\"\0\x12Y\n\x0eListContainers\x12!.runtime.v1.ListContainer\
    sRequest\x1a\".runtime.v1.ListContainersResponse\"\0\x12\\\n\x0fContaine\
    rStatus\x12\".runtime.v1.ContainerStatusRequest\x1a#.runtime.v1.Containe\
    rStatusResponse\"\0\x12w\n\x18UpdateContainerResources\x12+.runtime.v1.U\
    pdateContainerResourcesRequest\x1a,.runtime.v1.UpdateContainerResourcesR\
    esponse\"\0\x12e\n\x12ReopenContainerLog\x12%.runtime.v1.ReopenContainer\
    LogRequest\x1a&.runtime.v1.ReopenContainerLogResponse\"\0\x12G\n\x08Exec\
    Sync\x12\x1b.runtime.v1.ExecSyncRequest\x1a\x1c.runtime.v1.ExecSyncRespo\
    nse\"\0\x12;\n\x04Exec\x12\x17.runtime.v1.ExecRequest\x1a\x18.runtime.v1\
    .ExecResponse\"\0\x12A\n\x06Attach\x12\x19.runtime.v1.AttachRequest\x1a\
    \x1a.runtime.v1.AttachResponse\"\0\x12P\n\x0bPortForward\x12\x1e.runtime\
    .v1.PortForwardRequest\x1a\x1f.runtime.v1.PortForwardResponse\"\0\x12Y\n\
    \x0eContainerStats\x12!.runtime.v1.ContainerStatsRequest\x1a\".runtime.v\
    1.ContainerStatsResponse\"\0\x12e\n\x12ListContainerStats\x12%.runtime.v\
    1.ListContainerStatsRequest\x1a&.runtime.v1.ListContainerStatsResponse\"\
    \0\x12h\n\x13UpdateRuntimeConfig\x12&.runtime.v1.UpdateRuntimeConfigRequ\
    est\x1a'.runtime.v1.UpdateRuntimeConfigResponse\"\0\x12A\n\x06Status\x12\
    \x19.runtime.v1.StatusRequest\x1a\x1a.runtime.v1.StatusResponse\"\02\x9f\
    \x03\n\x0cImageService\x12M\n\nListImages\x12\x1d.runtime.v1.ListImagesR\
    equest\x1a\x1e.runtime.v1.ListImagesResponse\"\0\x12P\n\x0bImageStatus\
    \x12\x1e.runtime.v1.ImageStatusRequest\x1a\x1f.runtime.v1.ImageStatusRes\
    ponse\"\0\x12J\n\tPullImage\x12\x1c.runtime.v1.PullImageRequest\x1a\x1d.\
    runtime.v1.PullImageResponse\"\0\x12P\n\x0bRemoveImage\x12\x1e.runtime.v\
    1.RemoveImageRequest\x1a\x1f.runtime.v1.RemoveImageResponse\"\0\x12P\n\
    \x0bImageFsInfo\x12\x1e.runtime.v1.ImageFsInfoRequest\x1a\x1f.runtime.v1\
    .ImageFsInfoResponse\"\0B\x20Z\x02v1\xc8\xe2\x1e\x01\xe0\xe2\x1e\x01\x80\
    \xe2\x1e\x01\x90\xe3\x1e\0\xd8\xe1\x1e\0\xc8\xe1\x1e\x01\xd0\xe2\x1e\x01\
    b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
